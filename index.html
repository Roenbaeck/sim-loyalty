<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sim Loyalty - Customer Retention & Growth Simulator</title>
    <meta name="description" content="Interactive customer retention and growth simulator using a three-segment model. Model churn, predict growth, and fit to real data. Free tool for SaaS, e-commerce, and mobile apps.">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://roenbaeck.github.io/sim-loyalty/">
    <meta property="og:title" content="Sim Loyalty - Customer Retention & Growth Simulator">
    <meta property="og:description" content="Model customer retention and predict growth with a three-segment retention model. Fit to real data, export charts, and compare scenarios. Free interactive tool.">
    <meta property="og:image" content="https://roenbaeck.github.io/sim-loyalty/preview.png">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://roenbaeck.github.io/sim-loyalty/">
    <meta property="twitter:title" content="Sim Loyalty - Customer Retention & Growth Simulator">
    <meta property="twitter:description" content="Model customer retention and predict growth with a three-segment retention model. Fit to real data, export charts, and compare scenarios.">
    <meta property="twitter:image" content="https://roenbaeck.github.io/sim-loyalty/preview.png">
    
    <!-- Professional Font Stack -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/3.1.0/chartjs-plugin-annotation.min.js"></script>
    
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --bg-main: #f8fafc;
            --bg-panel: #ffffff;
            --text-heading: #1e293b;
            --text-body: #475569;
            --border-color: #e2e8f0;
            --accent-good: #10b981;
            --accent-warn: #f59e0b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: var(--bg-main);
            color: var(--text-body);
            line-height: 1.5;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* App Header */
        .app-header {
            background: var(--bg-panel);
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .app-logo {
            font-weight: 700;
            font-size: 1.25rem;
            color: var(--text-heading);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .app-logo svg {
            width: 24px;
            height: 24px;
            color: var(--primary);
        }

        .help-button {
            background: none;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-body);
            font-size: 1.125rem;
            font-weight: 600;
            transition: all 0.2s;
        }

        .help-button:hover {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-panel);
            border-radius: 12px;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            padding: 1.5rem 2rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modal-header h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-heading);
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--text-body);
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .modal-close:hover {
            background: var(--bg-main);
        }

        .modal-body {
            padding: 2rem;
        }

        .modal-body h3 {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-heading);
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        .modal-body h3:first-child {
            margin-top: 0;
        }

        .modal-body p {
            margin-bottom: 1rem;
            line-height: 1.6;
        }

        .modal-body ul {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        .modal-body li {
            margin-bottom: 0.5rem;
            line-height: 1.6;
        }

        .modal-body code {
            background: var(--bg-main);
            padding: 0.125rem 0.375rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            color: var(--primary);
        }

        /* Tooltip Styles */
        [data-tooltip] {
            position: relative;
            cursor: help;
        }

        [data-tooltip]:hover::before {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-8px);
            background: rgba(30, 41, 59, 0.95);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-size: 0.8125rem;
            white-space: normal;
            max-width: 250px;
            width: max-content;
            z-index: 100;
            line-height: 1.4;
            font-weight: 400;
        }

        [data-tooltip]:hover::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-2px);
            border: 6px solid transparent;
            border-top-color: rgba(30, 41, 59, 0.95);
            z-index: 100;
        }

        /* Main Layout */
        .app-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebar Controls */
        .controls-panel {
            width: 320px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border-color);
            padding: 2rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .panel-title {
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
            color: var(--text-heading);
            margin-bottom: 1.5rem;
        }

        .control-group {
            margin-bottom: 2rem;
        }

        .input-wrapper {
            margin-bottom: 1.25rem;
        }

        .input-wrapper label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-heading);
            margin-bottom: 0.5rem;
        }

        .input-field-container {
            position: relative;
        }

        .input-field-container input {
            width: 100%;
            padding: 0.625rem 0.875rem;
            padding-right: 2.5rem; /* Space for unit */
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.925rem;
            color: var(--text-heading);
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
            background: var(--bg-main);
        }

        .input-field-container input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            background: #fff;
        }

        .input-field-container input:disabled {
            background: #f1f5f9;
            color: #94a3b8;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .input-wrapper.disabled {
            opacity: 0.5;
        }

        .input-wrapper.disabled label {
            color: #94a3b8;
        }

        .input-unit {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #94a3b8;
            font-size: 0.875rem;
            pointer-events: none;
        }

        .update-btn {
            width: 100%;
            padding: 0.75rem;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: auto;
        }

        .update-btn:hover {
            background-color: var(--primary-hover);
        }

        .export-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .export-btn {
            padding: 0.5rem 0.75rem;
            background-color: var(--bg-main);
            color: var(--text-heading);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.8125rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .export-btn:hover {
            background-color: #e2e8f0;
            border-color: var(--primary);
        }

        .preset-select {
            width: 100%;
            padding: 0.625rem 0.875rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.925rem;
            color: var(--text-heading);
            background: var(--bg-main);
            cursor: pointer;
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
        }

        .preset-select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            background: #fff;
        }

        /* Main Visualization Area */
        .visualization-area {
            flex: 1;
            overflow-y: auto;
            padding: 2rem;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 2rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        .chart-card {
            background: var(--bg-panel);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .chart-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .chart-header h2 {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-heading);
        }

        .kpi-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            border-bottom: 1px solid var(--border-color);
        }

        .kpi-item {
            padding: 1.25rem 1.5rem;
            border-right: 1px solid var(--border-color);
        }
        .kpi-item:last-child { border-right: none; }

        .kpi-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
            color: var(--text-body);
            margin-bottom: 0.5rem;
        }

        .kpi-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-heading);
        }
        .kpi-value.highlight { color: var(--primary); }

        .full-width .kpi-grid {
            grid-template-columns: 1fr;
        }

        .chart-body {
            padding: 1.5rem;
            background: #fff;
            height: 400px;
            position: relative;
        }

        /* Responsive adjustments */
        @media (max-width: 1024px) {
            .app-container {
                flex-direction: column;
                overflow-y: auto;
            }
            .controls-panel {
                width: 100%;
                height: auto;
                overflow-y: visible;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 2rem;
            }
            .update-btn { grid-column: 1 / -1; }
            body { height: auto; }
            .visualization-area { overflow-y: visible; }
        }

        /* Curve Fitting Section */
        .fit-section {
            border-top: 2px solid var(--border-color);
            padding-top: 1.5rem;
            margin-top: 1rem;
        }

        .fit-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding: 0.75rem;
            background: var(--bg-main);
            border-radius: 6px;
            margin-bottom: 1rem;
            transition: background 0.2s;
        }

        .fit-toggle:hover {
            background: #e2e8f0;
        }

        .fit-toggle-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-heading);
        }

        .fit-toggle-icon {
            transition: transform 0.2s;
        }

        .fit-toggle-icon.expanded {
            transform: rotate(180deg);
        }

        .fit-content {
            display: none;
        }

        .fit-content.visible {
            display: block;
        }

        .fit-textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            resize: vertical;
            min-height: 80px;
            background: var(--bg-main);
            color: var(--text-heading);
        }

        .fit-textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .fit-btn {
            width: 100%;
            padding: 0.75rem;
            background-color: var(--accent-good);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 0.75rem;
        }

        .fit-btn:hover {
            background-color: #059669;
            transform: translateY(-1px);
        }

        .fit-result {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: #f0fdf4;
            border: 1px solid #86efac;
            border-radius: 6px;
            font-size: 0.875rem;
            color: #166534;
            display: none;
        }

        .fit-result.visible {
            display: block;
        }

        .fit-result.error {
            background: #fef2f2;
            border-color: #fca5a5;
            color: #991b1b;
        }

        .fit-help {
            font-size: 0.75rem;
            color: var(--text-body);
            margin-top: 0.5rem;
            line-height: 1.4;
        }

        @media (max-width: 768px) {
            .grid-container { grid-template-columns: 1fr; }
            .controls-panel { grid-template-columns: 1fr; gap: 0; }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="app-header">
        <div class="app-logo">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>
            Sim Loyalty
        </div>
        <button class="help-button" onclick="toggleHelp()" aria-label="Help">
            <span>?</span>
        </button>
    </header>

    <!-- Help Modal -->
    <div class="modal-overlay" id="helpModal" onclick="closeHelpIfClickOutside(event)">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìñ How to Use Sim Loyalty</h2>
                <button class="modal-close" onclick="toggleHelp()" aria-label="Close">&times;</button>
            </div>
            <div class="modal-body">
                <h3>üéØ What is Sim Loyalty?</h3>
                <p>Sim Loyalty helps you model customer retention and predict long-term growth using a three-segment retention model. Instead of assuming all customers behave the same, we divide them into groups based on how long they stick around.</p>

                <h3>üìä The Three-Segment Model</h3>
                <p>Customers naturally fall into different retention patterns:</p>
                <ul>
                    <li><strong>Short-term</strong>: High churn rate (~90%/month). These are exploratory users who try your product but don't stick around.</li>
                    <li><strong>Medium-term</strong>: Moderate churn rate (~10%/month). Regular users who engage but may eventually leave.</li>
                    <li><strong>Long-term</strong>: Low churn rate (~1%/month). Your most engaged, longTerm customers.</li>
                </ul>
                <p>Each segment follows <strong>exponential decay</strong>: <code>remaining(t) = initial √ó (1 - churn)^t</code></p>

                <h3>üöÄ Getting Started</h3>
                <p><strong>Quick Start:</strong> Select a preset from <strong>Presets & Saved Sets</strong> dropdown (SaaS, E-commerce, Mobile App, or Enterprise B2B) to see example parameters.</p>
                <p><strong>Manual Setup:</strong></p>
                <ul>
                    <li><strong>Step 1:</strong> Set your <strong>Monthly Customer Acquisition</strong></li>
                    <li><strong>Step 2:</strong> Define your <strong>Retention Segments</strong> (must sum to 100%)</li>
                    <li><strong>Step 3:</strong> Click <strong>Run Simulation</strong> to see results</li>
                </ul>
                <p><strong>üí° Tip:</strong> Save your parameters with a custom name to quickly switch between scenarios!</p>

                <h3>üéØ Using Real Data (Advanced)</h3>
                <p>If you have actual retention data from your analytics:</p>
                <ul>
                    <li>Click <strong>"üéØ Fit Model to Data"</strong></li>
                    <li>Paste retention percentages (one per month, starting at 100%)</li>
                    <li>Click <strong>Fit Parameters</strong> to calculate optimal segment parameters</li>
                    <li>Your actual data appears as <strong>light blue dots</strong> on the retention chart</li>
                    <li>The blue line shows the fitted model - compare visually!</li>
                </ul>

                <h3>üíæ Save & Share Your Work</h3>
                <ul>
                    <li><strong>Save Named Sets:</strong> Enter a name and click üíæ Save to store parameters (including fitted data)</li>
                    <li><strong>Load Presets:</strong> Use built-in examples (SaaS, E-commerce, Mobile App, Enterprise)</li>
                    <li><strong>Export Charts:</strong> Download retention or growth charts as PNG images</li>
                    <li><strong>Export Data:</strong> Download simulation results as CSV for Excel/Sheets</li>
                    <li><strong>Share Links:</strong> Click üîó Copy Link to share your exact parameters with colleagues</li>
                </ul>

                <h3>üìà Understanding the Charts</h3>
                <p><strong>Single Cohort Retention:</strong> Shows how one group of customers decays over time. Light blue dots (if present) show your actual data vs. the fitted model (blue line).</p>
                <p><strong>Multi-Cohort Growth:</strong> Shows your total customer base when adding new cohorts monthly. The dashed line shows the theoretical ceiling (asymptote).</p>

                <h3>üìä Key Metrics Explained</h3>
                <ul>
                    <li><strong>Cohort Half-Life (Median):</strong> Time when 50% of customers have churned</li>
                    <li><strong>Mean Lifetime:</strong> Average customer lifespan (weighted by segment size)</li>
                    <li><strong>Growth Asymptote:</strong> Steady-state customer base where new acquisition = total churn</li>
                </ul>

                <h3>üí° Tips</h3>
                <ul>
                    <li>Try the built-in presets to learn the model quickly</li>
                    <li>Save multiple scenarios to compare different strategies</li>
                    <li>Use real data fitting for accuracy - the blue dots show fit quality</li>
                    <li>Export charts for presentations and reports</li>
                    <li>Share links with teammates to discuss assumptions</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Main App -->
    <div class="app-container">
        <!-- Left Sidebar Controls -->
        <aside class="controls-panel">
            <div class="control-group">
                <h3 class="panel-title">Cohort Dynamics</h3>
                <div class="fit-help" style="margin-bottom: 1rem;">
                    Model your customer acquisition and retention over time.
                </div>
                
                <div class="input-wrapper">
                    <label for="cohortSize" data-tooltip="Number of new customers acquired each month">Monthly Customer Acquisition</label>
                    <div class="input-field-container">
                        <input type="number" id="cohortSize" value="1000" min="1" step="1">
                        <span class="input-unit">users</span>
                    </div>
                </div>

                <div class="input-wrapper">
                    <label for="timePeriods" data-tooltip="How many months to simulate into the future">Simulation Duration</label>
                    <div class="input-field-container">
                        <input type="number" id="timePeriods" value="36" min="1" step="1">
                        <span class="input-unit">months</span>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h3 class="panel-title">Retention Segments</h3>
                <div class="fit-help" style="margin-bottom: 1rem;">
                    Divide your cohort into groups based on customer longevity and retention behavior.
                </div>
                
                <div class="input-wrapper">
                    <label for="shortTermPercent" data-tooltip="Percentage of new customers who are exploratory users with high churn">Short-term Segment Size</label>
                    <div class="input-field-container">
                        <input type="number" id="shortTermPercent" value="20" min="0" max="100" step="0.1">
                        <span class="input-unit">%</span>
                    </div>
                </div>

                <div class="input-wrapper">
                    <label for="shortTermChurnRate" data-tooltip="Monthly churn rate for short-term customers (typically 70-95%)">Short-term Churn Rate</label>
                    <div class="input-field-container">
                        <input type="number" id="shortTermChurnRate" value="90" min="0" max="100" step="0.1">
                        <span class="input-unit">% / mo</span>
                    </div>
                </div>

                <div class="input-wrapper">
                    <label for="mediumTermPercent" data-tooltip="Percentage of new customers who are regular users with moderate retention">Medium-term Segment Size</label>
                    <div class="input-field-container">
                        <input type="number" id="mediumTermPercent" value="60" min="0" max="100" step="0.1">
                        <span class="input-unit">%</span>
                    </div>
                </div>

                <div class="input-wrapper">
                    <label for="mediumTermChurnRate" data-tooltip="Monthly churn rate for medium-term customers (typically 5-15%)">Medium-term Churn Rate</label>
                    <div class="input-field-container">
                        <input type="number" id="mediumTermChurnRate" value="10" min="0" max="100" step="0.1">
                        <span class="input-unit">% / mo</span>
                    </div>
                </div>

                <div class="input-wrapper">
                    <label for="longTermPercent" data-tooltip="Percentage of new customers who become highly engaged with low churn">Long-term Segment Size</label>
                    <div class="input-field-container">
                        <input type="number" id="longTermPercent" value="20" min="0" max="100" step="0.1">
                        <span class="input-unit">%</span>
                    </div>
                </div>

                <div class="input-wrapper">
                    <label for="longTermChurnRate" data-tooltip="Monthly churn rate for long-term longTerm customers (typically 0.5-3%)">Long-term Churn Rate</label>
                    <div class="input-field-container">
                        <input type="number" id="longTermChurnRate" value="1" min="0" max="100" step="0.1">
                        <span class="input-unit">% / mo</span>
                    </div>
                </div>

                <!-- Curve Fitting Section -->
                <div class="fit-section">
                    <div class="fit-toggle" onclick="toggleFitPanel()">
                        <span class="fit-toggle-title">üéØ Fit Model to Data</span>
                        <span class="fit-toggle-icon" id="fitToggleIcon">‚ñº</span>
                    </div>
                    <div class="fit-content" id="fitContent">
                        <label style="display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.5rem;">
                            Retention Data (% remaining)
                        </label>
                        <textarea 
                            id="retentionData" 
                            class="fit-textarea" 
                            placeholder="Enter retention percentages, one per line or comma-separated:&#10;100&#10;82&#10;73&#10;65&#10;58&#10;52&#10;..."></textarea>
                        <div class="fit-help">
                            Paste your cohort retention data starting at 100%. Each value represents the percentage of customers remaining after each period. Your actual data will appear as light blue points on the retention chart.
                        </div>
                        <button class="fit-btn" onclick="fitModelToData()">Fit Parameters</button>
                        <div class="fit-result" id="fitResult"></div>
                    </div>
                </div>
            </div>

            <button class="update-btn" onclick="updateCharts()">Run Simulation</button>

            <!-- Presets & Saved Sets Section -->
            <div class="control-group" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                <h3 class="panel-title">Presets & Saved Sets</h3>
                
                <div class="input-wrapper">
                    <label for="presetSelect">Load Example or Saved Set</label>
                    <select id="presetSelect" onchange="loadPreset()" class="preset-select">
                        <option value="">-- Select --</option>
                        <optgroup label="Example Presets">
                            <option value="saas">SaaS Startup</option>
                            <option value="ecommerce">E-commerce</option>
                            <option value="mobile">Mobile App</option>
                            <option value="enterprise">Enterprise B2B</option>
                        </optgroup>
                        <optgroup label="Your Saved Sets" id="savedSetsGroup">
                        </optgroup>
                    </select>
                </div>

                <div class="input-wrapper">
                    <label for="saveSetName">Save Current Parameters As</label>
                    <div style="display: flex; gap: 0.5rem;">
                        <input type="text" id="saveSetName" placeholder="My Scenario" class="input-field-container" style="flex: 1; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 6px;">
                        <button class="export-btn" onclick="saveNamedSet()" style="width: auto; padding: 0.5rem 1rem;">üíæ</button>
                    </div>
                </div>

                <button class="export-btn" onclick="manageSavedSets()" style="width: 100%; margin-top: 0.5rem;">
                    üóëÔ∏è Manage Saved Sets
                </button>
            </div>

            <!-- Export Section -->
            <div class="control-group" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                <h3 class="panel-title">Export & Share</h3>
                
                <div class="export-buttons">
                    <button class="export-btn" onclick="downloadRetentionChart()" title="Download retention chart as PNG">
                        Retention PNG
                    </button>
                    <button class="export-btn" onclick="downloadGrowthChart()" title="Download growth chart as PNG">
                        Growth PNG
                    </button>
                    <button class="export-btn" onclick="exportToCSV()" title="Export simulation data to CSV">
                        Export CSV
                    </button>
                    <button class="export-btn" onclick="copyShareableLink()" title="Copy shareable link with current parameters">
                        Copy Link
                    </button>
                </div>
            </div>
        </aside>

        <!-- Main Visualization Area -->
        <main class="visualization-area">
            <div class="grid-container">
                <!-- Chart 1: Retention -->
                <div class="chart-card">
                    <div class="chart-header">
                        <h2>Single Cohort Retention</h2>
                    </div>
                    <div class="kpi-grid">
                        <div class="kpi-item">
                            <div class="kpi-label" data-tooltip="Time when 50% of the cohort has churned (median customer lifetime)">Cohort Half-Life</div>
                            <div class="kpi-value" id="medianDisplay">--</div>
                        </div>
                        <div class="kpi-item">
                            <div class="kpi-label" data-tooltip="Average customer lifespan, weighted by segment sizes">Mean Lifetime</div>
                            <div class="kpi-value" id="meanDisplay">--</div>
                        </div>
                    </div>
                    <div class="chart-body">
                        <canvas id="retentionChart"></canvas>
                    </div>
                </div>

                <!-- Chart 2: Growth -->
                <div class="chart-card full-width">
                    <div class="chart-header">
                        <h2>Total Customer Base Growth</h2>
                    </div>
                    <div class="kpi-grid">
                        <div class="kpi-item" style="border-right: none;">
                            <div class="kpi-label" data-tooltip="Steady-state customer base where new acquisitions equal total churn">Theoretical Ceiling (Asymptote)</div>
                            <div class="kpi-value highlight" id="asymptoteDisplay">--</div>
                            <div style="font-size: 0.8rem; color: var(--text-body); margin-top: 4px;" id="asymptoteFormula"></div>
                        </div>
                    </div>
                    <div class="chart-body">
                        <canvas id="growthChart"></canvas>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // --- Global State ---
        let actualRetentionData = null; // Store actual data points from curve fitting

        // --- Chart Global Configuration for a more professional look ---
        Chart.defaults.font.family = "'Inter', -apple-system, BlinkMacSystemFont, sans-serif";
        Chart.defaults.color = '#64748b';
        Chart.defaults.scale.grid.color = '#f1f5f9';
        Chart.defaults.plugins.tooltip.backgroundColor = 'rgba(30, 41, 59, 0.9)';
        Chart.defaults.plugins.tooltip.padding = 12;
        Chart.defaults.plugins.tooltip.cornerRadius = 8;

        // --- Segment UI Management ---
        function updateChurnFieldStates() {
            const segments = [
                { percentId: 'shortTermPercent', churnId: 'shortTermChurnRate' },
                { percentId: 'mediumTermPercent', churnId: 'mediumTermChurnRate' },
                { percentId: 'longTermPercent', churnId: 'longTermChurnRate' }
            ];

            segments.forEach(segment => {
                const percentValue = parseFloat(document.getElementById(segment.percentId).value);
                const churnField = document.getElementById(segment.churnId);
                const churnWrapper = churnField.closest('.input-wrapper');
                
                if (percentValue === 0) {
                    churnField.disabled = true;
                    churnWrapper.classList.add('disabled');
                } else {
                    churnField.disabled = false;
                    churnWrapper.classList.remove('disabled');
                }
            });
        }

        // Add event listeners to segment size fields
        document.addEventListener('DOMContentLoaded', function() {
            ['shortTermPercent', 'mediumTermPercent', 'longTermPercent'].forEach(id => {
                document.getElementById(id).addEventListener('input', updateChurnFieldStates);
            });
            // Initialize on load
            updateChurnFieldStates();
        });

        // --- Curve Fitting Functions ---
        function toggleFitPanel() {
            const content = document.getElementById('fitContent');
            const icon = document.getElementById('fitToggleIcon');
            content.classList.toggle('visible');
            icon.classList.toggle('expanded');
        }

        function parseRetentionData(input) {
            // Parse input - supports comma-separated or line-separated values
            const values = input
                .split(/[\n,]+/)
                .map(v => v.trim())
                .filter(v => v.length > 0)
                .map(v => parseFloat(v));
            
            // Validate
            if (values.length < 4) {
                throw new Error('Need at least 4 data points for fitting');
            }
            if (values.some(v => isNaN(v) || v < 0 || v > 100)) {
                throw new Error('All values must be valid percentages (0-100)');
            }
            if (values[0] !== 100) {
                throw new Error('First value should be 100% (starting cohort)');
            }
            
            // Convert to decimals
            return values.map(v => v / 100);
        }

        function retentionModel(t, params) {
            const [shortTermPct, mediumTermPct, longTermPct, shortTermChurn, mediumTermChurn, longTermChurn] = params;
            return shortTermPct * Math.pow(1 - shortTermChurn, t) + 
                   mediumTermPct * Math.pow(1 - mediumTermChurn, t) + 
                   longTermPct * Math.pow(1 - longTermChurn, t);
        }

        function calculateError(params, data) {
            // Sum of squared errors
            let error = 0;
            for (let t = 0; t < data.length; t++) {
                const predicted = retentionModel(t, params);
                const actual = data[t];
                error += Math.pow(predicted - actual, 2);
            }
            return error;
        }

        function fitModelToData() {
            const resultDiv = document.getElementById('fitResult');
            const input = document.getElementById('retentionData').value;
            
            try {
                // Parse data
                const data = parseRetentionData(input);
                
                // Store actual data for visualization
                actualRetentionData = data;
                
                // Show processing
                resultDiv.className = 'fit-result visible';
                resultDiv.innerHTML = 'üîÑ Fitting model... This may take a few seconds.';
                
                // Run optimization in a timeout to allow UI update
                setTimeout(() => {
                    try {
                        const result = optimizeParameters(data);
                        
                        // Update input fields with fitted parameters
                        document.getElementById('shortTermPercent').value = (result.shortTermPercent * 100).toFixed(1);
                        document.getElementById('shortTermChurnRate').value = (result.shortTermChurn * 100).toFixed(1);
                        document.getElementById('mediumTermPercent').value = (result.mediumTermPercent * 100).toFixed(1);
                        document.getElementById('mediumTermChurnRate').value = (result.mediumTermChurn * 100).toFixed(1);
                        document.getElementById('longTermPercent').value = (result.longTermPercent * 100).toFixed(1);
                        document.getElementById('longTermChurnRate').value = (result.longTermChurn * 100).toFixed(1);
                        
                        // Update churn field states (disable if segment is 0%)
                        updateChurnFieldStates();
                        
                        // Show success message
                        resultDiv.className = 'fit-result visible';
                        resultDiv.innerHTML = `
                            <strong>‚úÖ Model fitted successfully!</strong><br>
                            shortTerm Segment: ${(result.shortTermPercent * 100).toFixed(1)}% (${(result.shortTermChurn * 100).toFixed(1)}% churn)<br>
                            mediumTerm Segment: ${(result.mediumTermPercent * 100).toFixed(1)}% (${(result.mediumTermChurn * 100).toFixed(1)}% churn)<br>
                            longTerm Segment: ${(result.longTermPercent * 100).toFixed(1)}% (${(result.longTermChurn * 100).toFixed(1)}% churn)<br>
                            R¬≤ = ${result.rSquared.toFixed(4)} (fit quality)
                        `;
                        
                        // Update charts
                        updateCharts();
                    } catch (error) {
                        resultDiv.className = 'fit-result visible error';
                        resultDiv.innerHTML = '‚ùå Optimization failed: ' + error.message;
                    }
                }, 100);
                
            } catch (error) {
                resultDiv.className = 'fit-result visible error';
                resultDiv.innerHTML = '‚ùå ' + error.message;
            }
        }

        function optimizeParameters(data) {
            // Nelder-Mead simplex optimization for 3-segment model
            // Heuristics for initial guess
            const firstDrop = 1 - data[1]; // How much churned in first period
            const finalRetention = data[data.length - 1];
            
            // Initial guess: [shortTermPct, mediumTermPct, longTermPct, shortTermChurn, mediumTermChurn, longTermChurn]
            let bestParams = [
                Math.min(0.4, firstDrop * 0.8),  // shortTermPct (estimate from first drop)
                0.4,                              // mediumTermPct
                0.2,                              // longTermPct (remaining)
                0.95,                             // shortTermChurn (very high)
                0.10,                             // mediumTermChurn (medium)
                0.01                              // longTermChurn (low)
            ];
            
            // Normalize segment percentages to sum to 1
            const segmentSum = bestParams[0] + bestParams[1] + bestParams[2];
            bestParams[0] /= segmentSum;
            bestParams[1] /= segmentSum;
            bestParams[2] /= segmentSum;
            
            let bestError = calculateError(bestParams, data);
            
            // Grid search for a good starting point (coarser due to more dimensions)
            for (let tp = 0; tp <= 0.5; tp += 0.2) {
                for (let mp = 0.3; mp <= 0.6; mp += 0.15) {
                    const lp = 1 - tp - mp;
                    if (lp < 0 || lp > 1) continue;
                    
                    for (let tc = 0.7; tc <= 0.99; tc += 0.1) {
                        for (let mc = 0.05; mc <= 0.25; mc += 0.05) {
                            for (let lc = 0; lc <= 0.05; lc += 0.02) {
                                const params = [tp, mp, lp, tc, mc, lc];
                                const error = calculateError(params, data);
                                if (error < bestError) {
                                    bestError = error;
                                    bestParams = [...params];
                                }
                            }
                        }
                    }
                }
            }
            
            // Nelder-Mead refinement
            const result = nelderMead(bestParams, data);
            
            // Calculate R¬≤
            const mean = data.reduce((a, b) => a + b, 0) / data.length;
            const totalSS = data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0);
            const rSquared = 1 - (result.error / totalSS);
            
            // Normalize segments to sum to 100%
            let shortTermPct = Math.max(0, result.params[0]);
            let mediumTermPct = Math.max(0, result.params[1]);
            let longTermPct = Math.max(0, result.params[2]);
            const total = shortTermPct + mediumTermPct + longTermPct;
            
            return {
                shortTermPercent: shortTermPct / total,
                mediumTermPercent: mediumTermPct / total,
                longTermPercent: longTermPct / total,
                shortTermChurn: Math.max(0, Math.min(0.99, result.params[3])),
                mediumTermChurn: Math.max(0.001, Math.min(0.99, result.params[4])),
                longTermChurn: Math.max(0, Math.min(0.99, result.params[5])),
                rSquared: rSquared
            };
        }

        function nelderMead(initialParams, data, maxIterations = 200) {
            const alpha = 1.0;  // Reflection
            const gamma = 2.0;  // Expansion
            const rho = 0.5;    // Contraction
            const sigma = 0.5;  // Shrink
            
            // Create initial simplex
            const n = initialParams.length;
            let simplex = [initialParams];
            
            for (let i = 0; i < n; i++) {
                const point = [...initialParams];
                point[i] += 0.05; // Small perturbation
                simplex.push(point);
            }
            
            // Evaluate simplex
            let errors = simplex.map(p => calculateError(p, data));
            
            for (let iter = 0; iter < maxIterations; iter++) {
                // Sort by error
                const indices = errors.map((e, i) => i).sort((a, b) => errors[a] - errors[b]);
                simplex = indices.map(i => simplex[i]);
                errors = indices.map(i => errors[i]);
                
                // Check convergence
                if (errors[n] - errors[0] < 1e-8) break;
                
                // Calculate centroid (excluding worst point)
                const centroid = new Array(n).fill(0);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        centroid[j] += simplex[i][j];
                    }
                }
                for (let j = 0; j < n; j++) {
                    centroid[j] /= n;
                }
                
                // Reflection
                const reflected = centroid.map((c, i) => c + alpha * (c - simplex[n][i]));
                const reflectedError = calculateError(reflected, data);
                
                if (reflectedError < errors[0]) {
                    // Expansion
                    const expanded = centroid.map((c, i) => c + gamma * (reflected[i] - c));
                    const expandedError = calculateError(expanded, data);
                    
                    if (expandedError < reflectedError) {
                        simplex[n] = expanded;
                        errors[n] = expandedError;
                    } else {
                        simplex[n] = reflected;
                        errors[n] = reflectedError;
                    }
                } else if (reflectedError < errors[n - 1]) {
                    simplex[n] = reflected;
                    errors[n] = reflectedError;
                } else {
                    // Contraction
                    const contracted = centroid.map((c, i) => c + rho * (simplex[n][i] - c));
                    const contractedError = calculateError(contracted, data);
                    
                    if (contractedError < errors[n]) {
                        simplex[n] = contracted;
                        errors[n] = contractedError;
                    } else {
                        // Shrink
                        for (let i = 1; i <= n; i++) {
                            simplex[i] = simplex[0].map((s0, j) => s0 + sigma * (simplex[i][j] - s0));
                            errors[i] = calculateError(simplex[i], data);
                        }
                    }
                }
            }
            
            return { params: simplex[0], error: errors[0] };
        }

        const retentionCtx = document.getElementById('retentionChart').getContext('2d');
        const growthCtx = document.getElementById('growthChart').getContext('2d');
        
        const retentionChart = new Chart(retentionCtx, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        align: 'end',
                        labels: { 
                            boxWidth: 12, 
                            usePointStyle: true,
                            filter: function(item) {
                                // Only show legend if we have actual data points
                                return item.text !== 'Model Prediction' || actualRetentionData;
                            }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                // Round to nearest whole number for user counts
                                label += Math.round(context.parsed.y).toLocaleString();
                                return label;
                            }
                        }
                    },
                    annotation: { annotations: {} }
                },
                scales: {
                    x: {
                        title: { display: true, text: 'Months Since Acqusition', font: { weight: 500 } },
                        grid: { display: false }
                    },
                    y: {
                        beginAtZero: true,
                        title: { display: true, text: 'Users Remaining', font: { weight: 500 } }
                    }
                }
            }
        });
        
        const growthChart = new Chart(growthCtx, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                plugins: {
                    legend: {
                        position: 'top',
                        align: 'end',
                        labels: { boxWidth: 12, usePointStyle: true }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                // Round to nearest whole number for user counts
                                label += Math.round(context.parsed.y).toLocaleString();
                                return label;
                            }
                        }
                    },
                    annotation: { annotations: {} }
                },
                scales: {
                    x: {
                        title: { display: true, text: 'Months Passed', font: { weight: 500 } },
                        grid: { display: false }
                    },
                    y: {
                        beginAtZero: true,
                        title: { display: true, text: 'Total Active Customers', font: { weight: 500 } }
                    }
                }
            }
        });

        function updateCharts() {
            // Get input values
            const shortTermPercent = parseFloat(document.getElementById('shortTermPercent').value) / 100;
            const shortTermChurn = parseFloat(document.getElementById('shortTermChurnRate').value) / 100;
            const mediumTermPercent = parseFloat(document.getElementById('mediumTermPercent').value) / 100;
            const mediumTermChurn = parseFloat(document.getElementById('mediumTermChurnRate').value) / 100;
            const longTermPercent = parseFloat(document.getElementById('longTermPercent').value) / 100;
            const longTermChurn = parseFloat(document.getElementById('longTermChurnRate').value) / 100;
            const cohortSize = parseFloat(document.getElementById('cohortSize').value);
            const timePeriods = parseInt(document.getElementById('timePeriods').value);

            // Simple validation
            if ([shortTermPercent, shortTermChurn, mediumTermPercent, mediumTermChurn, longTermPercent, longTermChurn, cohortSize, timePeriods].some(isNaN)) {
                alert('Please check your inputs for valid numbers.');
                return;
            }

            // Validate that segment percentages sum to 100% (allow 99-101% range)
            const segmentSum = shortTermPercent + mediumTermPercent + longTermPercent;
            if (segmentSum < 0.99 || segmentSum > 1.01) {
                alert(`Warning: Segment percentages must sum to approximately 100%.\nCurrent sum: ${(segmentSum * 100).toFixed(1)}%\n\nshortTerm: ${(shortTermPercent * 100).toFixed(1)}%\nmediumTerm: ${(mediumTermPercent * 100).toFixed(1)}%\nlongTerm: ${(longTermPercent * 100).toFixed(1)}%`);
                return;
            }

            const T = cohortSize * shortTermPercent;
            const M = cohortSize * mediumTermPercent;
            const L = cohortSize * longTermPercent;
            const timePoints = Array.from({ length: timePeriods + 1 }, (_, i) => i);

            // --- RETENTION CALCULATION (3-segment model) ---
            const retentionData = timePoints.map(t => {
                let shortTermRem = (shortTermChurn === 1) ? (t === 0 ? T : 0) : T * Math.pow(1 - shortTermChurn, t);
                let transRem = (mediumTermChurn === 1) ? (t === 0 ? M : 0) : M * Math.pow(1 - mediumTermChurn, t);
                let longTermRem = (longTermChurn === 1) ? (t === 0 ? L : 0) : L * Math.pow(1 - longTermChurn, t);
                return shortTermRem + transRem + longTermRem;
            });

            // --- KPI CALCS: MEDIAN & MEAN ---
            let medianLifetimeStr = 'Infinite';
            let medianLifetime = Infinity;
            const halfCohort = cohortSize / 2;

            if (retentionData[timePeriods] < halfCohort) {
                 // Find where it crosses 50%
                 for (let i = 0; i < timePeriods; i++) {
                    if (retentionData[i] >= halfCohort && retentionData[i+1] < halfCohort) {
                        // Linear interpolation for smoother display
                        const slope = retentionData[i+1] - retentionData[i];
                        medianLifetime = i + (halfCohort - retentionData[i]) / slope;
                        medianLifetimeStr = medianLifetime.toFixed(1) + ' mo';
                        break;
                    }
                 }
            } else if (mediumTermChurn > 0 || longTermChurn > 0) {
                 medianLifetimeStr = '> ' + timePeriods + ' mo';
            }

            let meanLifetime = Infinity;
            if (shortTermChurn > 0 && mediumTermChurn > 0 && longTermChurn > 0) {
                // Weighted average of segment lifetimes
                meanLifetime = (shortTermPercent / shortTermChurn) + (mediumTermPercent / mediumTermChurn) + (longTermPercent / longTermChurn);
                document.getElementById('meanDisplay').innerText = meanLifetime.toFixed(1) + ' mo';
            } else {
                document.getElementById('meanDisplay').innerText = 'Infinite';
            }
            document.getElementById('medianDisplay').innerText = medianLifetimeStr;

            // --- GROWTH CALCULATION (3-segment model) ---
             const growthData = timePoints.map(t => {
                // Sum of all cohorts up to time t (each with 3 segments)
                let total = 0;
                for (let k = 0; k <= t; k++) {
                    const age = t - k;
                    total += (T * Math.pow(1 - shortTermChurn, age)) + 
                             (M * Math.pow(1 - mediumTermChurn, age)) + 
                             (L * Math.pow(1 - longTermChurn, age));
                }
                return total;
            });

            // --- KPI CALCS: ASYMPTOTE ---
            let asymptoteStr = 'No Ceiling (Linear Growth)';
            let isLinear = (shortTermChurn === 0 || mediumTermChurn === 0 || longTermChurn === 0);
            let asymptoteVal = null;
            let linearAsymptoteData = null;

            if (!isLinear) {
                // All segments have churn - finite asymptote
                asymptoteVal = (T / shortTermChurn) + (M / mediumTermChurn) + (L / longTermChurn);
                asymptoteStr = Math.round(asymptoteVal).toLocaleString();
                document.getElementById('asymptoteFormula').innerText = 'Steady state where churn equals new acquisition';
            } else {
                document.getElementById('asymptoteFormula').innerText = 'At least one segment has 0% churn';
                
                // Calculate linear asymptote - sum up the segments
                linearAsymptoteData = timePoints.map(t => {
                    let asymptote = 0;
                    
                    // shortTerm contribution
                    if (shortTermChurn === 0) {
                        asymptote += T * (t + 1); // Linear growth
                    } else {
                        asymptote += T / shortTermChurn; // Steady state
                    }
                    
                    // mediumTerm contribution
                    if (mediumTermChurn === 0) {
                        asymptote += M * (t + 1); // Linear growth
                    } else {
                        asymptote += M / mediumTermChurn; // Steady state
                    }
                    
                    // longTerm contribution
                    if (longTermChurn === 0) {
                        asymptote += L * (t + 1); // Linear growth
                    } else {
                        asymptote += L / longTermChurn; // Steady state
                    }
                    
                    return asymptote;
                });
                
                const growingSegments = [];
                if (shortTermChurn === 0) growingSegments.push(`${T.toFixed(0)} (short-term)`);
                if (mediumTermChurn === 0) growingSegments.push(`${M.toFixed(0)} (medium-term)`);
                if (longTermChurn === 0) growingSegments.push(`${L.toFixed(0)} (long-term)`);
                
                // Calculate steady-state contribution from segments with churn
                let steadyState = 0;
                if (shortTermChurn > 0) steadyState += T / shortTermChurn;
                if (mediumTermChurn > 0) steadyState += M / mediumTermChurn;
                if (longTermChurn > 0) steadyState += L / longTermChurn;
                
                asymptoteStr = `Linear: ${growingSegments.join(' + ')} √ó (t + 1) + ${Math.round(steadyState).toLocaleString()}`;
            }
            document.getElementById('asymptoteDisplay').innerText = asymptoteStr;


            // --- UPDATE CHARTS ---
            
            // 1. Retention Update
            const accentColor = '#2563eb';
            const retentionDatasets = [{
                label: 'Model Prediction',
                data: retentionData,
                borderColor: accentColor,
                backgroundColor: accentColor,
                borderWidth: 2.5,
                pointRadius: 0,
                pointHoverRadius: 6,
                fill: {
                    target: 'origin',
                    above: 'rgba(37, 99, 235, 0.05)' // Very subtle fill
                }
            }];
            
            // Add actual data points if they exist (from curve fitting)
            if (actualRetentionData && actualRetentionData.length > 0) {
                // Convert actual data to absolute numbers (multiply by cohort size)
                const actualPoints = actualRetentionData.map(pct => pct * cohortSize);
                
                retentionDatasets.push({
                    label: 'Actual Data',
                    data: actualPoints,
                    type: 'scatter',
                    borderColor: '#60a5fa',
                    backgroundColor: '#60a5fa',
                    pointRadius: 5,
                    pointHoverRadius: 7,
                    borderWidth: 2,
                    showLine: false
                });
            }
            
            retentionChart.data = {
                labels: timePoints,
                datasets: retentionDatasets
            };

            // Retention Annotations (Median and Mean lines)
            retentionChart.options.plugins.annotation.annotations = {};
            if (isFinite(medianLifetime) && medianLifetime <= timePeriods) {
                 retentionChart.options.plugins.annotation.annotations.medianLine = {
                    type: 'line',
                    xMin: medianLifetime,
                    xMax: medianLifetime,
                    borderColor: '#ef4444',
                    borderWidth: 2,
                    borderDash: [4, 4],
                    label: { display: true, content: 'Median', position: 'end', backgroundColor: '#ef4444', font: {size: 10} }
                 };
            }
            if (isFinite(meanLifetime) && meanLifetime >= 0 && meanLifetime <= timePeriods) {
                 retentionChart.options.plugins.annotation.annotations.meanLine = {
                    type: 'line',
                    xMin: meanLifetime,
                    xMax: meanLifetime,
                    borderColor: '#f97316',
                    borderWidth: 2,
                    borderDash: [6, 3],
                    label: { display: true, content: 'Mean', position: 'start', backgroundColor: '#f97316', font: {size: 10} }
                 };
            }
            retentionChart.update();

            // 2. Growth Update
            const growthColor = '#059669'; // Emerald green
            const datasets = [{
                label: 'Total Customers',
                data: growthData,
                borderColor: growthColor,
                backgroundColor: growthColor,
                borderWidth: 2.5,
                pointRadius: 0,
                pointHoverRadius: 6
            }];
            
            // Add linear asymptote as a separate dataset if it exists
            if (linearAsymptoteData) {
                datasets.push({
                    label: 'Linear Asymptote',
                    data: linearAsymptoteData,
                    borderColor: '#a855f7',
                    borderWidth: 2,
                    borderDash: [8, 4],
                    fill: false,
                    pointRadius: 0,
                    pointHoverRadius: 0
                });
            }
            
            growthChart.data = {
                labels: timePoints,
                datasets: datasets
            };

            // Growth Annotations (Asymptote)
            growthChart.options.plugins.annotation.annotations = {};
            if (asymptoteVal !== null) {
                 growthChart.options.plugins.annotation.annotations.ceilingLine = {
                    type: 'line',
                    yMin: asymptoteVal,
                    yMax: asymptoteVal,
                    borderColor: '#ef4444', // Red for ceiling
                    borderWidth: 1,
                    borderDash: [6, 6],
                    label: { display: true, content: 'Ceiling', position: 'end', backgroundColor: 'rgba(239, 68, 68, 0.8)', font: {size: 10} }
                 };
                 // Ensure y-axis can see the asymptote if it's close
                 growthChart.options.scales.y.suggestedMax = Math.max(growthData[timePeriods] * 1.1, asymptoteVal * 1.05);
            } else {
                growthChart.options.scales.y.suggestedMax = undefined;
            }

            growthChart.update();
        }

        // Help Modal Functions
        function toggleHelp() {
            const modal = document.getElementById('helpModal');
            modal.classList.toggle('active');
        }

        function closeHelpIfClickOutside(event) {
            if (event.target.id === 'helpModal') {
                toggleHelp();
            }
        }

        // Keyboard support for help modal
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const modal = document.getElementById('helpModal');
                if (modal.classList.contains('active')) {
                    toggleHelp();
                }
            }
            // Press Enter anywhere in the controls panel to update charts
            if (event.key === 'Enter' && event.target.tagName === 'INPUT') {
                updateCharts();
            }
        });

        // --- Presets ---
        const PRESETS = {
            saas: {
                name: "SaaS Startup",
                cohortSize: "1000",
                timePeriods: "36",
                shortTermPercent: "30.0",
                shortTermChurnRate: "85.0",
                mediumTermPercent: "50.0",
                mediumTermChurnRate: "12.0",
                longTermPercent: "20.0",
                longTermChurnRate: "2.0"
            },
            ecommerce: {
                name: "E-commerce",
                cohortSize: "2000",
                timePeriods: "24",
                shortTermPercent: "40.0",
                shortTermChurnRate: "70.0",
                mediumTermPercent: "45.0",
                mediumTermChurnRate: "15.0",
                longTermPercent: "15.0",
                longTermChurnRate: "5.0"
            },
            mobile: {
                name: "Mobile App",
                cohortSize: "5000",
                timePeriods: "12",
                shortTermPercent: "75.0",
                shortTermChurnRate: "95.0",
                mediumTermPercent: "20.0",
                mediumTermChurnRate: "25.0",
                longTermPercent: "5.0",
                longTermChurnRate: "8.0"
            },
            enterprise: {
                name: "Enterprise B2B",
                cohortSize: "50",
                timePeriods: "60",
                shortTermPercent: "10.0",
                shortTermChurnRate: "50.0",
                mediumTermPercent: "40.0",
                mediumTermChurnRate: "5.0",
                longTermPercent: "50.0",
                longTermChurnRate: "1.0"
            }
        };

        // --- Export & Share Functions ---
        
        function downloadRetentionChart() {
            const canvas = document.getElementById('retentionChart');
            const url = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'retention-chart.png';
            link.href = url;
            link.click();
        }

        function downloadGrowthChart() {
            const canvas = document.getElementById('growthChart');
            const url = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'growth-chart.png';
            link.href = url;
            link.click();
        }

        function getAllParameters() {
            return {
                cohortSize: document.getElementById('cohortSize').value,
                timePeriods: document.getElementById('timePeriods').value,
                shortTermPercent: document.getElementById('shortTermPercent').value,
                shortTermChurnRate: document.getElementById('shortTermChurnRate').value,
                mediumTermPercent: document.getElementById('mediumTermPercent').value,
                mediumTermChurnRate: document.getElementById('mediumTermChurnRate').value,
                longTermPercent: document.getElementById('longTermPercent').value,
                longTermChurnRate: document.getElementById('longTermChurnRate').value,
                actualData: actualRetentionData // Include fitted data if exists
            };
        }

        function setAllParameters(params) {
            document.getElementById('cohortSize').value = params.cohortSize;
            document.getElementById('timePeriods').value = params.timePeriods;
            document.getElementById('shortTermPercent').value = params.shortTermPercent;
            document.getElementById('shortTermChurnRate').value = params.shortTermChurnRate;
            document.getElementById('mediumTermPercent').value = params.mediumTermPercent;
            document.getElementById('mediumTermChurnRate').value = params.mediumTermChurnRate;
            document.getElementById('longTermPercent').value = params.longTermPercent;
            document.getElementById('longTermChurnRate').value = params.longTermChurnRate;
            
            // Restore actual retention data if it was saved
            if (params.actualData) {
                actualRetentionData = params.actualData;
            }
        }

        function copyShareableLink() {
            const params = getAllParameters();
            delete params.actualData; // Don't include in URL (too long)
            const urlParams = new URLSearchParams(params);
            const shareUrl = window.location.origin + window.location.pathname + '?' + urlParams.toString();
            
            navigator.clipboard.writeText(shareUrl).then(() => {
                alert('‚úÖ Link copied to clipboard! Share this URL to let others view your simulation.');
            }).catch(() => {
                // Fallback for older browsers
                prompt('Copy this link:', shareUrl);
            });
        }

        function loadPreset() {
            const select = document.getElementById('presetSelect');
            const value = select.value;
            
            if (!value) return;
            
            // Check if it's a built-in preset
            if (PRESETS[value]) {
                setAllParameters(PRESETS[value]);
                updateCharts();
                select.value = ""; // Reset selection
                return;
            }
            
            // Otherwise it's a saved set
            const savedSets = JSON.parse(localStorage.getItem('simlongTermtySavedSets') || '{}');
            if (savedSets[value]) {
                setAllParameters(savedSets[value].params);
                updateCharts();
                select.value = ""; // Reset selection
            }
        }

        function saveNamedSet() {
            const name = document.getElementById('saveSetName').value.trim();
            if (!name) {
                alert('‚ö†Ô∏è Please enter a name for this parameter set.');
                return;
            }
            
            const savedSets = JSON.parse(localStorage.getItem('simlongTermtySavedSets') || '{}');
            savedSets[name] = {
                params: getAllParameters(),
                timestamp: new Date().toISOString()
            };
            
            localStorage.setItem('simlongTermtySavedSets', JSON.stringify(savedSets));
            document.getElementById('saveSetName').value = '';
            updateSavedSetsList();
            alert(`‚úÖ "${name}" saved successfully!`);
        }

        function updateSavedSetsList() {
            const savedSets = JSON.parse(localStorage.getItem('simlongTermtySavedSets') || '{}');
            const group = document.getElementById('savedSetsGroup');
            group.innerHTML = '';
            
            const names = Object.keys(savedSets).sort();
            if (names.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = '(no saved sets)';
                option.disabled = true;
                group.appendChild(option);
            } else {
                names.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    group.appendChild(option);
                });
            }
        }

        function manageSavedSets() {
            const savedSets = JSON.parse(localStorage.getItem('simlongTermtySavedSets') || '{}');
            const names = Object.keys(savedSets);
            
            if (names.length === 0) {
                alert('‚ÑπÔ∏è No saved sets to manage.');
                return;
            }
            
            const list = names.map((name, i) => `${i + 1}. ${name}`).join('\n');
            const toDelete = prompt(`Your saved sets:\n${list}\n\nEnter the name of a set to DELETE (or cancel):`);
            
            if (toDelete && savedSets[toDelete]) {
                if (confirm(`Delete "${toDelete}"?`)) {
                    delete savedSets[toDelete];
                    localStorage.setItem('simlongTermtySavedSets', JSON.stringify(savedSets));
                    updateSavedSetsList();
                    alert(`‚úÖ "${toDelete}" deleted.`);
                }
            } else if (toDelete) {
                alert('‚ö†Ô∏è Set not found.');
            }
        }

        function exportToCSV() {
            // Get current parameters
            const cohortSize = parseFloat(document.getElementById('cohortSize').value);
            const timePeriods = parseInt(document.getElementById('timePeriods').value);
            const shortTermPercent = parseFloat(document.getElementById('shortTermPercent').value) / 100;
            const shortTermChurn = parseFloat(document.getElementById('shortTermChurnRate').value) / 100;
            const mediumTermPercent = parseFloat(document.getElementById('mediumTermPercent').value) / 100;
            const mediumTermChurn = parseFloat(document.getElementById('mediumTermChurnRate').value) / 100;
            const longTermPercent = parseFloat(document.getElementById('longTermPercent').value) / 100;
            const longTermChurn = parseFloat(document.getElementById('longTermChurnRate').value) / 100;

            const T = cohortSize * shortTermPercent;
            const M = cohortSize * mediumTermPercent;
            const L = cohortSize * longTermPercent;

            // Build CSV
            let csv = 'Month,Short-term Users,Medium-term Users,Long-term Users,Total Retention,Total Customer Base\n';
            
            for (let t = 0; t <= timePeriods; t++) {
                const shortTermRem = T * Math.pow(1 - shortTermChurn, t);
                const transRem = M * Math.pow(1 - mediumTermChurn, t);
                const longTermRem = L * Math.pow(1 - longTermChurn, t);
                const totalRetention = shortTermRem + transRem + longTermRem;
                
                // Calculate total customer base (all cohorts)
                let totalBase = 0;
                for (let k = 0; k <= t; k++) {
                    const age = t - k;
                    totalBase += (T * Math.pow(1 - shortTermChurn, age)) + 
                                 (M * Math.pow(1 - mediumTermChurn, age)) + 
                                 (L * Math.pow(1 - longTermChurn, age));
                }
                
                csv += `${t},${Math.round(shortTermRem)},${Math.round(transRem)},${Math.round(longTermRem)},${Math.round(totalRetention)},${Math.round(totalBase)}\n`;
            }

            // Download
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'sim-longTermty-data.csv';
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }

        // Load parameters from URL on page load
        function loadFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('cohortSize')) {
                const params = {
                    cohortSize: urlParams.get('cohortSize'),
                    timePeriods: urlParams.get('timePeriods'),
                    shortTermPercent: urlParams.get('shortTermPercent'),
                    shortTermChurnRate: urlParams.get('shortTermChurnRate'),
                    mediumTermPercent: urlParams.get('mediumTermPercent'),
                    mediumTermChurnRate: urlParams.get('mediumTermChurnRate'),
                    longTermPercent: urlParams.get('longTermPercent'),
                    longTermChurnRate: urlParams.get('longTermChurnRate')
                };
                setAllParameters(params);
            }
        }

        // Init
        loadFromURL();
        updateSavedSetsList();
        updateCharts();
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sim Loyalty - Customer Retention & Growth Simulator</title>
    <meta name="description" content="Interactive customer retention and growth simulator using a three-segment model. Model churn, predict growth, and fit to real data. Free tool for SaaS, e-commerce, and mobile apps.">
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%232563eb' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M22 12h-4l-3 9L9 3l-3 9H2'/></svg>">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://roenbaeck.github.io/sim-loyalty/">
    <meta property="og:title" content="Sim Loyalty - Customer Retention & Growth Simulator">
    <meta property="og:description" content="Model customer retention and predict growth with a three-segment retention model. Fit to real data, export charts, and compare scenarios. Free interactive tool.">
    <meta property="og:image" content="https://roenbaeck.github.io/sim-loyalty/preview.png">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://roenbaeck.github.io/sim-loyalty/">
    <meta property="twitter:title" content="Sim Loyalty - Customer Retention & Growth Simulator">
    <meta property="twitter:description" content="Model customer retention and predict growth with a three-segment retention model. Fit to real data, export charts, and compare scenarios.">
    <meta property="twitter:image" content="https://roenbaeck.github.io/sim-loyalty/preview.png">
    
    <!-- Professional Font Stack -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --bg-main: #f8fafc;
            --bg-panel: #ffffff;
            --text-heading: #1e293b;
            --text-body: #475569;
            --border-color: #e2e8f0;
            --accent-good: #10b981;
            --accent-warn: #f59e0b;
        }

        [data-theme="dark"] {
            --primary: #3b82f6;
            --primary-hover: #60a5fa;
            --bg-main: #0f172a;
            --bg-panel: #1e293b;
            --text-heading: #f1f5f9;
            --text-body: #cbd5e1;
            --border-color: #334155;
            --accent-good: #10b981;
            --accent-warn: #f59e0b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: var(--bg-main);
            color: var(--text-body);
            line-height: 1.5;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* App Header */
        .app-header {
            background: var(--bg-panel);
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .app-logo {
            font-weight: 700;
            font-size: 1.25rem;
            color: var(--text-heading);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .app-logo svg {
            width: 24px;
            height: 24px;
            color: var(--primary);
        }

        .help-button {
            background: none;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-body);
            font-size: 1.125rem;
            font-weight: 600;
            transition: all 0.2s;
        }

        .help-button:hover {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }

        .theme-toggle {
            background: none;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-body);
            font-size: 1.125rem;
            transition: all 0.2s;
            margin-left: 0.5rem;
        }

        .theme-toggle:hover {
            background: var(--bg-main);
            border-color: var(--primary);
            color: var(--primary);
        }

        .header-buttons {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-panel);
            border-radius: 12px;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            padding: 1.5rem 2rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modal-header h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-heading);
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--text-body);
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .modal-close:hover {
            background: var(--bg-main);
        }

        .modal-body {
            padding: 2rem;
        }

        .modal-body h3 {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-heading);
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        .modal-body h3:first-child {
            margin-top: 0;
        }

        .modal-body p {
            margin-bottom: 1rem;
            line-height: 1.6;
        }

        .modal-body ul {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        .modal-body li {
            margin-bottom: 0.5rem;
            line-height: 1.6;
        }

        .modal-body code {
            background: var(--bg-main);
            padding: 0.125rem 0.375rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            color: var(--primary);
        }

        .modal-body blockquote {
            margin-top: 1rem;
            margin-bottom: 1rem;
            padding: 0.75rem 1rem;
            background: var(--bg-main);
            border-left: 4px solid var(--primary);
            border-radius: 4px;
        }

        .modal-body blockquote p {
            margin-bottom: 0;
        }

        /* Tooltip Styles */
        [data-tooltip] {
            position: relative;
            cursor: help;
        }

        [data-tooltip]:hover::before {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-8px);
            background: rgba(30, 41, 59, 0.95);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-size: 0.8125rem;
            white-space: normal;
            max-width: 250px;
            width: max-content;
            z-index: 100;
            line-height: 1.4;
            font-weight: 400;
        }

        [data-tooltip]:hover::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-2px);
            border: 6px solid transparent;
            border-top-color: rgba(30, 41, 59, 0.95);
            z-index: 100;
        }

        /* Main Layout */
        .app-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebar Controls */
        .controls-panel {
            width: 320px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border-color);
            padding: 2rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .panel-title {
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
            color: var(--text-heading);
            margin-bottom: 1.5rem;
        }

        .control-group {
            margin-bottom: 2rem;
        }

        .input-wrapper {
            margin-bottom: 1.25rem;
        }

        .input-wrapper label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-heading);
            margin-bottom: 0.5rem;
        }

        .input-field-container {
            position: relative;
        }

        .input-field-container input {
            width: 100%;
            padding: 0.625rem 0.875rem;
            padding-right: 4.5rem; /* Space for unit and spinner arrows */
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.925rem;
            color: var(--text-heading);
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
            background: var(--bg-main);
        }

        .input-field-container input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            background: var(--bg-panel);
        }

        .input-field-container input:disabled {
            background: #f1f5f9;
            color: #94a3b8;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .input-wrapper.disabled {
            opacity: 0.5;
        }

        .input-wrapper.disabled label {
            color: #94a3b8;
        }

        .input-unit {
            position: absolute;
            right: 12px; 
            top: 50%;
            transform: translateY(-50%);
            color: #94a3b8;
            font-size: 0.875rem;
            pointer-events: none;
        }

        .segment-sum-indicator {
            margin-top: 1rem;
            padding: 0.75rem;
            background: var(--bg-main);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .segment-sum-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
            color: var(--text-body);
            margin-bottom: 0.5rem;
        }

        .segment-sum-bar-container {
            background: #e2e8f0;
            height: 24px;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .segment-sum-bar {
            height: 100%;
            transition: width 0.3s ease, background-color 0.3s ease;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .segment-sum-bar.valid {
            background: linear-gradient(90deg, #10b981 0%, #059669 100%);
        }

        .segment-sum-bar.invalid {
            background: linear-gradient(90deg, #f59e0b 0%, #d97706 100%);
        }

        .segment-sum-bar.over {
            background: linear-gradient(90deg, #ef4444 0%, #dc2626 100%);
        }

        .segment-sum-text {
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--text-heading);
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            z-index: 2;
        }

        .range-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, var(--primary) 0%, var(--primary) 50%, #e2e8f0 50%, #e2e8f0 100%);
            outline: none;
            margin-top: 0.5rem;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: transform 0.15s ease;
            margin-top: -6px; /* Center thumb on track (track is 6px, thumb is 18px, so offset by (18-6)/2 = 6px) */
        }

        .range-slider::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }

        .range-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: transform 0.15s ease;
        }

        .range-slider::-moz-range-thumb:hover {
            transform: scale(1.15);
        }

        .range-slider::-webkit-slider-runnable-track {
            height: 6px;
            border-radius: 3px;
        }

        .range-slider::-moz-range-track {
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
        }

        .update-btn {
            width: 100%;
            padding: 0.75rem;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: auto;
        }

        .update-btn:hover {
            background-color: var(--primary-hover);
        }

        .export-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .export-btn {
            padding: 0.5rem 0.75rem;
            background-color: var(--bg-main);
            color: var(--text-heading);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.8125rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .export-btn:hover {
            background-color: #e2e8f0;
            border-color: var(--primary);
        }

        .panel-footer {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.8125rem;
            color: var(--text-body);
        }

        .panel-footer a {
            color: var(--primary);
            text-decoration: none;
            transition: opacity 0.2s;
        }

        .panel-footer a:hover {
            opacity: 0.8;
            text-decoration: underline;
        }

        .preset-select {
            width: 100%;
            padding: 0.625rem 0.875rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.925rem;
            color: var(--text-heading);
            background: var(--bg-main);
            cursor: pointer;
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
        }

        .preset-select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            background: var(--bg-panel);
        }

        .preset-select option {
            background: var(--bg-panel);
            color: var(--text-heading);
        }

        /* Main Visualization Area */
        .visualization-area {
            flex: 1;
            overflow-y: auto;
            padding: 2rem;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 2rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        .chart-card {
            background: var(--bg-panel);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .chart-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .chart-header h2 {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-heading);
        }

        .kpi-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            border-bottom: 1px solid var(--border-color);
            min-height: 15ex;
        }

        .kpi-item {
            padding: 1.25rem 1.5rem;
            border-right: 1px solid var(--border-color);
        }
        .kpi-item:last-child { border-right: none; }

        .kpi-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
            color: var(--text-body);
            margin-bottom: 0.5rem;
        }

        .kpi-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-heading);
        }
        .kpi-value.highlight { color: var(--primary); }

        .full-width .kpi-grid {
            grid-template-columns: 1fr;
        }

        .chart-body {
            padding: 1.5rem;
            background: var(--bg-panel);
            height: 400px;
            position: relative;
        }

        .chart-body canvas {
            background: transparent !important;
        }

        /* Responsive adjustments */
        @media (max-width: 1024px) {
            .app-container {
                flex-direction: column;
                overflow-y: auto;
            }
            .controls-panel {
                width: 100%;
                height: auto;
                overflow-y: visible;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 2rem;
            }
            .update-btn { grid-column: 1 / -1; }
            body { height: auto; }
            .visualization-area { overflow-y: visible; }
        }

        /* Curve Fitting Section */
        .fit-section {
            border: 2px solid var(--primary);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1.5rem;
            background: linear-gradient(135deg, rgba(37, 99, 235, 0.03) 0%, rgba(37, 99, 235, 0.08) 100%);
        }

        .fit-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding: 0.875rem 1rem;
            background: var(--primary);
            border-radius: 6px;
            margin-bottom: 1rem;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(37, 99, 235, 0.2);
        }

        .fit-toggle:hover {
            background: var(--primary-hover);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(37, 99, 235, 0.3);
        }

        .fit-toggle-title {
            font-size: 0.9375rem;
            font-weight: 600;
            color: white;
        }

        .fit-toggle-icon {
            transition: transform 0.2s;
            color: white;
            font-size: 1.125rem;
        }

        .fit-toggle-icon.expanded {
            transform: rotate(180deg);
        }

        .fit-content {
            display: none;
        }

        .fit-content.visible {
            display: block;
        }

        .fit-textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            resize: vertical;
            min-height: 80px;
            background: var(--bg-main);
            color: var(--text-heading);
        }

        .fit-textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .fit-btn {
            width: 100%;
            padding: 0.75rem;
            background-color: var(--accent-good);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 0.75rem;
        }

        .fit-btn:hover {
            background-color: #059669;
            transform: translateY(-1px);
        }

        .fit-result {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: #f0fdf4;
            border: 1px solid #86efac;
            border-radius: 6px;
            font-size: 0.875rem;
            color: #166534;
            display: none;
        }

        .fit-result.visible {
            display: block;
        }

        .fit-result.error {
            background: #fef2f2;
            border-color: #fca5a5;
            color: #991b1b;
        }

        .fit-result.excellent {
            background: #f0fdf4;
            border-color: #86efac;
            color: #166534;
        }

        .fit-result.good {
            background: #fefce8;
            border-color: #fde047;
            color: #854d0e;
        }

        .fit-result.poor {
            background: #fef2f2;
            border-color: #fca5a5;
            color: #991b1b;
        }

        .fit-help {
            font-size: 0.75rem;
            color: var(--text-body);
            margin-top: 0.5rem;
            line-height: 1.4;
        }

        @media (max-width: 768px) {
            .grid-container { grid-template-columns: 1fr; }
            .controls-panel { grid-template-columns: 1fr; gap: 0; }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="app-header">
        <div class="app-logo">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>
            Sim Loyalty
        </div>
        <div class="header-buttons">
            <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle dark mode" title="Toggle dark mode">
                <span id="themeIcon">üåô</span>
            </button>
            <button class="help-button" onclick="toggleHelp()" aria-label="Help">
                <span>?</span>
            </button>
        </div>
    </header>

    <!-- Help Modal -->
    <div class="modal-overlay" id="helpModal" onclick="closeHelpIfClickOutside(event)">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìñ How to Use Sim Loyalty</h2>
                <button class="modal-close" onclick="toggleHelp()" aria-label="Close">&times;</button>
            </div>
            <div class="modal-body">
                <h3>üéØ What is Sim Loyalty?</h3>
                <p>Sim Loyalty helps you model customer retention and predict long-term growth using a three-segment retention model. Instead of assuming all customers behave the same, we divide them into groups based on how long they stick around.</p>

                <h3>üìä The Three-Segment Model</h3>
                <p>Customers naturally fall into different retention patterns:</p>
                <ul>
                    <li><strong>Short-term</strong>: High churn rate (~90%/month). These are exploratory users who try your product but don't stick around.</li>
                    <li><strong>Medium-term</strong>: Moderate churn rate (~10%/month). Regular users who engage but may eventually leave.</li>
                    <li><strong>Long-term</strong>: Low churn rate (~1%/month). Your most engaged, loyal customers.</li>
                </ul>
                <p>Each segment follows <strong>exponential decay</strong>: <code>remaining(t) = initial √ó (1 - churn)^t</code></p>

                <h3>ü§î Why Model Instead of Using Raw Data?</h3>
                <p>Great question! Here's why modeling adds value:</p>
                <ul>
                    <li><strong>üîÆ Future Prediction:</strong> Your data shows 12 months; the model predicts months 13-36+ using learned patterns</li>
                    <li><strong>üß™ What-If Scenarios:</strong> Test "What if we reduce churn by 2%?" - impossible with historical data alone</li>
                    <li><strong>üìä Multi-Cohort Growth:</strong> Your data = one cohort. Model = total customer base from overlapping monthly cohorts</li>
                    <li><strong>üéØ Steady-State Planning:</strong> Calculate asymptote (ceiling) - where you'll level off at current acquisition rates</li>
                    <li><strong>üí° Actionable Insights:</strong> "30% short-term, 50% medium-term, 20% loyal" drives strategy better than a list of numbers</li>
                    <li><strong>üìâ Noise Filtering:</strong> Model reveals underlying trend, smoothing random variation and one-time events</li>
                    <li><strong>‚öñÔ∏è Comparison:</strong> Compare products/cohorts by segment parameters, not just curves</li>
                </ul>
                <p><strong>Bottom line:</strong> Actual data = rearview mirror. Model = windshield. You need both to drive forward!</p>

                <h3>üöÄ Getting Started</h3>
                <p><strong>Quick Start:</strong> Select a preset from <strong>Presets & Saved Sets</strong> dropdown (SaaS, E-commerce, Mobile App, or Enterprise B2B) to see example parameters.</p>
                <p><strong>Manual Setup:</strong></p>
                <ul>
                    <li><strong>Step 1:</strong> Set your <strong>Monthly Customer Acquisition</strong></li>
                    <li><strong>Step 2:</strong> Define your <strong>Retention Segments</strong> (must sum to 100%)</li>
                    <li><strong>Step 3:</strong> Charts update automatically - no button click needed!</li>
                </ul>
                <p><strong>üí° Tip:</strong> Save your parameters with a custom name to quickly switch between scenarios!</p>

                <h3>‚ö° Interactive Features</h3>
                <p>The simulator includes several interactive features for fluid exploration:</p>
                <ul>
                    <li><strong>Range Sliders:</strong> Each segment parameter has a slider for quick, visual adjustments</li>
                    <li><strong>Live Auto-Updates:</strong> Charts update automatically 300ms after you stop adjusting parameters (no "Run Simulation" button needed)</li>
                    <li><strong>Segment Sum Indicator:</strong> A visual progress bar shows if your segments sum to 100% (green), under 100% (orange), or over 100% (red)</li>
                    <li><strong>Auto-Save via URL:</strong> Your parameters are automatically saved in the browser URL as you work - refreshing the page restores your exact state!</li>
                    <li><strong>Stacked Area Charts:</strong> See exactly how much each segment contributes to retention and growth over time</li>
                </ul>
                <p><strong>Pro Tip:</strong> The URL autosave means you can bookmark interesting scenarios or share your exact current state just by copying the URL!</p>

                <h3>üéØ Using Real Data (Advanced)</h3>
                <p>If you have actual retention data from your analytics:</p>
                <ul>
                    <li>Click <strong>"üéØ Fit Model to Data"</strong></li>
                    <li>Paste retention percentages (one per month, starting at 100%)</li>
                    <li>Click <strong>Fit Parameters</strong> to calculate optimal segment parameters</li>
                    <li>Your actual data appears as <strong>light blue dots</strong> on the retention chart</li>
                    <li>The blue line shows the fitted model - compare visually!</li>
                </ul>
                <p><strong>üî¨ Advanced Multi-Method Optimization:</strong> The curve fitting uses 4 different optimization algorithms simultaneously (Grid Search, Differential Evolution, Random Restart, and Simulated Annealing) and automatically selects the best result. This ensures robust fitting across diverse retention patterns, from simple exponential decay to complex multi-segment behaviors.</p>

                <h3>üíæ Save & Share Your Work</h3>
                <ul>
                    <li><strong>Save Named Sets:</strong> Enter a name and click üíæ Save to store parameters (including fitted data)</li>
                    <li><strong>Load Presets:</strong> Use built-in examples (SaaS, E-commerce, Mobile App, Enterprise)</li>
                    <li><strong>Export Charts:</strong> Download retention or growth charts as PNG images</li>
                    <li><strong>Export Data:</strong> Download simulation results as CSV for Excel/Sheets</li>
                    <li><strong>Share Links:</strong> Click üîó Copy Link to share your exact parameters with colleagues</li>
                </ul>

                <h3>üìà Understanding the Charts</h3>
                <p><strong>Single Cohort Retention:</strong> Shows how one group of customers decays over time. The stacked areas show the contribution of each segment (short-term, medium-term, long-term). Light blue dots (if present) show your actual data vs. the fitted model (blue line).</p>
                <p><strong>Multi-Cohort Growth:</strong> Shows your total customer base when adding new cohorts monthly. The stacked areas reveal how much each segment contributes to total growth. The dashed line shows the theoretical ceiling (asymptote).</p>

                <h3>üéØ Understanding Your Growth Ceiling (Asymptote)</h3>
                <p><strong>Your growth ceiling</strong> is the customer level you naturally approach when new customers per month and churn stay steady. It's the point where <strong>new in = customers out</strong>, so the total stops rising.</p>

                <h4>The "Leaky Bucket" Analogy</h4>
                <p>Think of your business as a bucket:</p>
                <ul>
                    <li><strong>Acquisition (the tap):</strong> A steady flow of new customers each month (e.g., 1,000/month).</li>
                    <li><strong>Customers (the water level):</strong> Your total active customer base.</li>
                    <li><strong>Churn (the holes):</strong> Each month, a fixed percent applies at the segment level; in total, the leak behaves like a percent that settles to a steady <em>effective churn</em> as cohorts accumulate.</li>
                </ul>

                <p>When you're small, the leak is tiny. As you grow, the <em>same percent</em> of a bigger base becomes a bigger absolute leak. Growth naturally slows until the leak equals the tap.</p>

                <blockquote>
                    <p><strong>Rule of thumb:</strong> Ceiling ‚âà <strong>monthly acquisition √∑ effective monthly churn</strong>.<br>
                    Example: 1,000 per month and 5% churn ‚Üí about <strong>20,000 customers</strong>.</p>
                </blockquote>

                <p>In this tool, your <em>effective churn</em> comes from the three segments you set (short, medium, long). Early on, the overall percent leaking each month can change as the mix of cohort ages stabilizes; the rule of thumb uses the steady-state effective churn that the model derives from your segments. We calculate and show the ceiling on the Growth chart and in the ‚ÄúGrowth Ceiling‚Äù KPI.</p>

                <p><strong>How to raise the ceiling:</strong></p>
                <ul>
                    <li>Increase acquisition (open the tap) ‚Üí ceiling rises linearly.</li>
                    <li>Reduce effective churn (smaller holes) ‚Üí ceiling rises faster for every point of churn you cut.</li>
                </ul>

                <h3>üìä Key Metrics Explained</h3>
                <ul>
                    <li><strong>Cohort Half-Life (Median):</strong> Time when 50% of customers have churned</li>
                    <li><strong>Mean Lifetime:</strong> Average customer lifespan (weighted by segment size)</li>
                    <li><strong>Avg Error (MAPE):</strong> Average error between model and data (&lt;5% = excellent, 5-10% = good, &gt;10% = review fit visually)</li>
                    <li><strong>R¬≤:</strong> Variance explained (can be misleading for visual fit - use Avg Error instead)</li>
                </ul>

                <h3>‚ö†Ô∏è Model Limitations</h3>
                <p>The three-segment exponential model works best for:</p>
                <ul>
                    <li>‚úÖ Steady churn patterns (SaaS, subscriptions, consumer apps)</li>
                    <li>‚úÖ Multiple distinct customer behavior groups</li>
                    <li>‚úÖ Exponential decay within segments (including 0% churn = plateau)</li>
                    <li>‚úÖ Gradual reactivation (captured as lower effective churn rates)</li>
                </ul>
                <p>It may struggle with:</p>
                <ul>
                    <li>‚ùå S-curves (slow start, then rapid churn)</li>
                    <li>‚ùå U-curves/Smiley patterns (retention improving over time)</li>
                    <li>‚ùå Sudden step changes in retention</li>
                    <li>‚ùå Massive reactivation campaigns (churned users returning en masse)</li>
                    <li>‚ùå Network effects (retention improving as product matures)</li>
                    <li>‚ùå Seasonal or time-varying churn rates</li>
                </ul>
                <p><strong>Check the Avg Error %</strong> when fitting. If &gt;10%, visually inspect the light blue dots - look for systematic patterns that the model misses.</p>

                <h3>ÔøΩ Note on Acquisition Growth</h3>
                <p>This model assumes <strong>fixed monthly acquisition</strong> to isolate retention dynamics and calculate steady-state (asymptote). This assumption is realistic for:</p>
                <ul>
                    <li>Mature businesses in stable markets</li>
                    <li>Companies with consistent marketing spend</li>
                    <li>Market-share limited acquisition (e.g., B2B, niches)</li>
                </ul>
                <p>Fixed acquisition lets you answer key strategic questions:</p>
                <ul>
                    <li>"At 1,000 customers/month, what's our ceiling?"</li>
                    <li>"How much does improving retention lift our steady-state?"</li>
                </ul>
                <p><strong>For high-growth scenarios</strong> (e.g., 1,000 ‚Üí 1,500 ‚Üí 2,000/month), run multiple scenarios at different acquisition levels and interpolate externally. Mixing acquisition growth with retention modeling makes it harder to isolate what drives results.</p>

                <h3>üí° Tips</h3>
                <ul>
                    <li>Try the built-in presets to learn the model quickly</li>
                    <li>Save multiple scenarios to compare different strategies</li>
                    <li>Use real data fitting for accuracy - the light blue dots show fit quality</li>
                    <li>Watch the Avg Error % - if it's high, inspect the dots visually</li>
                    <li>Export charts for presentations and reports</li>
                    <li>Share links with teammates to discuss assumptions</li>
                    <li><strong>Interactive sliders:</strong> Use the range sliders below each parameter for fluid adjustments</li>
                    <li><strong>Auto-update:</strong> Charts update automatically as you adjust parameters (300ms delay)</li>
                    <li><strong>Segment sum indicator:</strong> Watch the progress bar to ensure segments sum to 100%</li>
                    <li><strong>Auto-save via URL:</strong> Your parameters are automatically saved in the URL - refresh won't lose your work!</li>
                </ul>

                <h3>üß™ Stress Test Examples</h3>
                <p>Try fitting these patterns to see model performance:</p>
                
                <p><strong>S-Curve (Poor Fit Expected):</strong><br>
                <code>100, 95, 90, 85, 75, 60, 40, 25, 18, 15, 13, 12</code><br>
                <em>Slow initial churn, then rapid - model struggles with this pattern</em></p>
                
                <p><strong>Smiley/U-Curve (Poor Fit Expected):</strong><br>
                <code>100, 70, 50, 40, 35, 38, 42, 47, 52, 56, 60, 63</code><br>
                <em>Retention improves over time (reactivation/network effects) - exponential decay can't capture this</em></p>
                
                <p><strong>Typical SaaS (Excellent Fit):</strong><br>
                <code>100, 82, 73, 65, 58, 52, 47, 43, 39, 36, 33, 31</code><br>
                <em>Classic exponential decay - model excels here</em></p>
                
                <p><strong>Plateau/Sticky Users (Excellent Fit):</strong><br>
                <code>100, 80, 70, 65, 63, 62, 61, 60, 60, 60, 60, 60</code><br>
                <em>Model handles this well with long-term segment at 0% churn</em></p>
            </div>
        </div>
    </div>

    <!-- Main App -->
    <div class="app-container">
        <!-- Left Sidebar Controls -->
        <aside class="controls-panel">
            <div class="control-group">
                <h3 class="panel-title">Cohort Dynamics</h3>
                <div class="fit-help" style="margin-bottom: 1rem;">
                    Model your customer acquisition and retention over time.
                </div>
                
                <div class="input-wrapper">
                    <label for="cohortSize" data-tooltip="Number of new customers acquired each month">Monthly Customer Acquisition</label>
                    <div class="input-field-container">
                        <input type="number" id="cohortSize" value="1000" min="1" step="1">
                        <span class="input-unit">users</span>
                    </div>
                </div>

                <div class="input-wrapper">
                    <label for="timePeriods" data-tooltip="How many months to simulate into the future">Simulation Duration</label>
                    <div class="input-field-container">
                        <input type="number" id="timePeriods" value="36" min="1" step="1">
                        <span class="input-unit">months</span>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h3 class="panel-title">Retention Segments</h3>
                <div class="fit-help" style="margin-bottom: 1rem;">
                    Divide your cohort into groups based on customer longevity and retention behavior.
                </div>
                
                <div class="input-wrapper">
                    <label for="shortTermPercent" data-tooltip="Percentage of new customers who are exploratory users with high churn">Short-term Segment Size</label>
                    <div class="input-field-container">
                        <input type="number" id="shortTermPercent" value="20" min="0" max="100" step="0.1">
                        <span class="input-unit">%</span>
                    </div>
                    <input type="range" id="shortTermPercentSlider" class="range-slider" min="0" max="100" step="0.1" value="20">
                </div>

                <div class="input-wrapper">
                    <label for="shortTermChurnRate" data-tooltip="Monthly churn rate for short-term customers (typically 70-95%)">Short-term Churn Rate</label>
                    <div class="input-field-container">
                        <input type="number" id="shortTermChurnRate" value="90" min="0" max="100" step="0.1">
                        <span class="input-unit">% / mo</span>
                    </div>
                    <input type="range" id="shortTermChurnRateSlider" class="range-slider" min="0" max="100" step="0.1" value="90">
                </div>

                <div class="input-wrapper">
                    <label for="mediumTermPercent" data-tooltip="Percentage of new customers who are regular users with moderate retention">Medium-term Segment Size</label>
                    <div class="input-field-container">
                        <input type="number" id="mediumTermPercent" value="60" min="0" max="100" step="0.1">
                        <span class="input-unit">%</span>
                    </div>
                    <input type="range" id="mediumTermPercentSlider" class="range-slider" min="0" max="100" step="0.1" value="60">
                </div>

                <div class="input-wrapper">
                    <label for="mediumTermChurnRate" data-tooltip="Monthly churn rate for medium-term customers (typically 5-15%)">Medium-term Churn Rate</label>
                    <div class="input-field-container">
                        <input type="number" id="mediumTermChurnRate" value="10" min="0" max="100" step="0.1">
                        <span class="input-unit">% / mo</span>
                    </div>
                    <input type="range" id="mediumTermChurnRateSlider" class="range-slider" min="0" max="100" step="0.1" value="10">
                </div>

                <div class="input-wrapper">
                    <label for="longTermPercent" data-tooltip="Percentage of new customers who become highly engaged with low churn">Long-term Segment Size</label>
                    <div class="input-field-container">
                        <input type="number" id="longTermPercent" value="20" min="0" max="100" step="0.1">
                        <span class="input-unit">%</span>
                    </div>
                    <input type="range" id="longTermPercentSlider" class="range-slider" min="0" max="100" step="0.1" value="20">
                </div>

                <div class="input-wrapper">
                    <label for="longTermChurnRate" data-tooltip="Monthly churn rate for long-term loyal customers (typically 0.5-3%)">Long-term Churn Rate</label>
                    <div class="input-field-container">
                        <input type="number" id="longTermChurnRate" value="1" min="0" max="100" step="0.1">
                        <span class="input-unit">% / mo</span>
                    </div>
                    <input type="range" id="longTermChurnRateSlider" class="range-slider" min="0" max="100" step="0.1" value="1">
                </div>

                <!-- Segment Sum Indicator -->
                <div class="segment-sum-indicator">
                    <div class="segment-sum-label">Segment Total</div>
                    <div class="segment-sum-bar-container">
                        <div class="segment-sum-bar valid" id="segmentSumBar" style="width: 100%"></div>
                        <div class="segment-sum-text" id="segmentSumText">100%</div>
                    </div>
                </div>

                <!-- Curve Fitting Section -->
                <div class="fit-section">
                    <div class="fit-toggle" onclick="toggleFitPanel()">
                        <span class="fit-toggle-title">üéØ Fit Model to Data</span>
                        <span class="fit-toggle-icon" id="fitToggleIcon">‚ñº</span>
                    </div>
                    <div class="fit-content" id="fitContent">
                        <label style="display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.5rem;">
                            Retention Data (% remaining)
                        </label>
                        <textarea 
                            id="retentionData" 
                            class="fit-textarea" 
                            placeholder="Enter retention percentages, one per line or comma-separated:&#10;100&#10;82&#10;73&#10;65&#10;58&#10;52&#10;..."></textarea>
                        <div class="fit-help">
                            Paste your cohort retention data starting at 100%. Each value represents the percentage of customers remaining after each period. Your actual data will appear as light blue points on the retention chart.
                        </div>
                        <button class="fit-btn" onclick="fitModelToData()">Fit Parameters</button>
                        <div class="fit-result" id="fitResult"></div>
                    </div>
                </div>
            </div>

            <button class="update-btn" onclick="updateCharts()">Refresh Charts</button>

            <!-- Presets & Saved Sets Section -->
            <div class="control-group" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                <h3 class="panel-title">Presets & Saved Sets</h3>
                
                <div class="input-wrapper">
                    <label for="presetSelect">Load Example or Saved Set</label>
                    <select id="presetSelect" onchange="loadPreset()" class="preset-select">
                        <option value="">-- Select --</option>
                        <optgroup label="Example Presets">
                            <option value="saas">SaaS Startup</option>
                            <option value="ecommerce">E-commerce</option>
                            <option value="mobile">Mobile App</option>
                            <option value="enterprise">Enterprise B2B</option>
                        </optgroup>
                        <optgroup label="Your Saved Sets" id="savedSetsGroup">
                        </optgroup>
                    </select>
                </div>

                <div class="input-wrapper">
                    <label for="saveSetName">Save Current Parameters As</label>
                    <div style="display: flex; gap: 0.5rem;">
                        <input type="text" id="saveSetName" placeholder="My Scenario" class="input-field-container" style="flex: 1; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-panel); color: var(--text-heading);">
                        <button class="export-btn" onclick="saveNamedSet()" style="width: auto; padding: 0.5rem 1rem;">üíæ</button>
                    </div>
                </div>

                <button class="export-btn" onclick="manageSavedSets()" style="width: 100%; margin-top: 0.5rem;">
                    üóëÔ∏è Manage Saved Sets
                </button>
            </div>

            <!-- Export Section -->
            <div class="control-group" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                <h3 class="panel-title">Export & Share</h3>
                
                <div class="export-buttons">
                    <button class="export-btn" onclick="downloadRetentionChart()" title="Download retention chart as PNG">
                        Retention PNG
                    </button>
                    <button class="export-btn" onclick="downloadGrowthChart()" title="Download growth chart as PNG">
                        Growth PNG
                    </button>
                    <button class="export-btn" onclick="exportToCSV()" title="Export simulation data to CSV">
                        Export CSV
                    </button>
                    <button class="export-btn" onclick="copyShareableLink()" title="Copy shareable link with current parameters">
                        Copy Link
                    </button>
                </div>
            </div>

            <!-- Footer with version and repository link -->
            <div class="panel-footer">
                <div style="margin-bottom: 0.5rem;">Version 1.0.0</div>
                <a href="https://github.com/Roenbaeck/sim-loyalty" target="_blank" rel="noopener noreferrer">
                    View on GitHub ‚Üí
                </a>
            </div>
        </aside>

        <!-- Main Visualization Area -->
        <main class="visualization-area">
            <div class="grid-container">
                <!-- Chart 1: Retention -->
                <div class="chart-card">
                    <div class="chart-header">
                        <h2>Single Cohort Retention</h2>
                    </div>
                    <div class="kpi-grid">
                        <div class="kpi-item">
                            <div class="kpi-label" data-tooltip="Time when 50% of the cohort has churned (median customer lifetime)">Cohort Half-Life</div>
                            <div class="kpi-value" id="medianDisplay">--</div>
                            <div id="segmentHalfLives" style="font-size: 0.75rem; color: var(--text-body); margin-top: 4px; display: none;"></div>
                        </div>
                        <div class="kpi-item">
                            <div class="kpi-label" data-tooltip="Average customer lifespan, weighted by segment sizes">Average Lifetime</div>
                            <div class="kpi-value" id="meanDisplay">--</div>
                            <div id="segmentMeans" style="font-size: 0.75rem; color: var(--text-body); margin-top: 4px; display: none;"></div>
                        </div>
                    </div>
                    <div class="chart-body">
                        <canvas id="retentionChart"></canvas>
                    </div>
                </div>

                <!-- Chart 2: Growth -->
                <div class="chart-card full-width">
                    <div class="chart-header">
                        <h2>Total Customer Base Growth</h2>
                    </div>
                    <div class="kpi-grid">
                        <div class="kpi-item" style="border-right: none;">
                            <div class="kpi-label" data-tooltip="The maximum number of customers you will reach if acquisition and churn rates stay the same. To raise this ceiling, you must either increase acquisition or decrease churn.">Growth Ceiling (Asymptote)</div>
                            <div class="kpi-value highlight" id="asymptoteDisplay">--</div>
                            <div style="font-size: 0.8rem; color: var(--text-body); margin-top: 4px;" id="asymptoteFormula"></div>
                        </div>
                    </div>
                    <div class="chart-body">
                        <canvas id="growthChart"></canvas>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // --- Global State ---
        let actualRetentionData = null; // Store actual data points from curve fitting

        // --- Chart Global Configuration for a more professional look ---
        Chart.defaults.font.family = "'Inter', -apple-system, BlinkMacSystemFont, sans-serif";
        Chart.defaults.color = '#64748b';
        Chart.defaults.scale.grid.color = '#f1f5f9';
        Chart.defaults.plugins.tooltip.backgroundColor = 'rgba(30, 41, 59, 0.9)';
        Chart.defaults.plugins.tooltip.padding = 12;
        Chart.defaults.plugins.tooltip.cornerRadius = 8;

        // Get theme-aware colors for chart elements
        function getChartColors() {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            return {
                totalLine: isDark ? '#f1f5f9' : '#1e293b',
                actualData: isDark ? '#bbddff' : '#000088',
                asymptoteLine: isDark ? '#f59e0b' : '#f59e0b',
                // Segment colors - blue-gray gradient for dark mode
                shortTerm: {
                    background: isDark ? 'rgba(41, 85, 165, 0.85)' : 'rgba(236, 72, 153, 0.7)'
                },
                mediumTerm: {
                    background: isDark ? 'rgba(70, 116, 199, 0.85)' : 'rgba(139, 92, 246, 0.7)'
                },
                longTerm: {
                    background: isDark ? 'rgba(118, 163, 244, 0.85)' : 'rgba(59, 130, 246, 0.7)'
                }
            };
        }

        // Update chart colors based on theme
        function updateChartColors() {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            
            Chart.defaults.color = isDark ? '#cbd5e1' : '#64748b';
            Chart.defaults.scale.grid.color = isDark ? '#334155' : '#f1f5f9';
            Chart.defaults.plugins.tooltip.backgroundColor = isDark ? 'rgba(30, 41, 59, 0.95)' : 'rgba(30, 41, 59, 0.9)';
            
            // Update scale border and tick colors
            const axisColor = isDark ? '#475569' : '#cbd5e1';
            
            // Update retention chart axes
            if (typeof retentionChart !== 'undefined' && retentionChart) {
                retentionChart.options.scales.x.grid.color = isDark ? '#334155' : '#f1f5f9';
                retentionChart.options.scales.x.ticks = { color: isDark ? '#cbd5e1' : '#64748b' };
                retentionChart.options.scales.x.border = { color: axisColor };
                retentionChart.options.scales.y.grid.color = isDark ? '#334155' : '#f1f5f9';
                retentionChart.options.scales.y.ticks = { color: isDark ? '#cbd5e1' : '#64748b' };
                retentionChart.options.scales.y.border = { color: axisColor };
            }
            
            // Update growth chart axes
            if (typeof growthChart !== 'undefined' && growthChart) {
                growthChart.options.scales.x.grid.color = isDark ? '#334155' : '#f1f5f9';
                growthChart.options.scales.x.ticks = { color: isDark ? '#cbd5e1' : '#64748b' };
                growthChart.options.scales.x.border = { color: axisColor };
                growthChart.options.scales.y.grid.color = isDark ? '#334155' : '#f1f5f9';
                growthChart.options.scales.y.ticks = { color: isDark ? '#cbd5e1' : '#64748b' };
                growthChart.options.scales.y.border = { color: axisColor };
            }
            
            // Update existing charts if they exist - this will trigger updateCharts which uses getChartColors()
            if (typeof retentionChart !== 'undefined' && retentionChart) {
                updateCharts();
            }
        }

        // --- Segment UI Management ---
        function updateChurnFieldStates() {
            const segments = [
                { percentId: 'shortTermPercent', churnId: 'shortTermChurnRate' },
                { percentId: 'mediumTermPercent', churnId: 'mediumTermChurnRate' },
                { percentId: 'longTermPercent', churnId: 'longTermChurnRate' }
            ];

            segments.forEach(segment => {
                const percentValue = parseFloat(document.getElementById(segment.percentId).value);
                const churnField = document.getElementById(segment.churnId);
                const churnWrapper = churnField.closest('.input-wrapper');
                
                if (percentValue === 0) {
                    churnField.disabled = true;
                    churnWrapper.classList.add('disabled');
                } else {
                    churnField.disabled = false;
                    churnWrapper.classList.remove('disabled');
                }
            });
        }

        // Add event listeners to segment size fields
        document.addEventListener('DOMContentLoaded', function() {
            // Load theme preference
            loadTheme();
            
            // Load state from URL if present
            const loadedFromURL = loadURLState();
            
            ['shortTermPercent', 'mediumTermPercent', 'longTermPercent'].forEach(id => {
                document.getElementById(id).addEventListener('input', updateChurnFieldStates);
                document.getElementById(id).addEventListener('input', updateSegmentSum);
            });
            // Initialize on load
            updateChurnFieldStates();
            updateSegmentSum();
            
            // Add auto-update listeners to all input fields
            const paramInputs = [
                'cohortSize', 'timePeriods',
                'shortTermPercent', 'shortTermChurnRate',
                'mediumTermPercent', 'mediumTermChurnRate',
                'longTermPercent', 'longTermChurnRate'
            ];
            
            paramInputs.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', debouncedUpdateCharts);
                }
            });
            
            // Setup slider synchronization
            setupSliderSync('shortTermPercent');
            setupSliderSync('shortTermChurnRate');
            setupSliderSync('mediumTermPercent');
            setupSliderSync('mediumTermChurnRate');
            setupSliderSync('longTermPercent');
            setupSliderSync('longTermChurnRate');
            
            // Initial render (after URL state is loaded and sliders are synced)
            updateCharts();
            if (loadedFromURL) {
                // If we loaded from URL, update the URL to ensure it's clean
                updateURLState();
            }
        });

        // Bidirectional sync between input and slider
        function setupSliderSync(inputId) {
            const input = document.getElementById(inputId);
            const slider = document.getElementById(inputId + 'Slider');
            
            if (!input || !slider) return;
            
            // Slider changes input
            slider.addEventListener('input', function() {
                input.value = this.value;
                input.dispatchEvent(new Event('input'));
                updateSliderBackground(slider);
            });
            
            // Input changes slider
            input.addEventListener('input', function() {
                slider.value = this.value;
                updateSliderBackground(slider);
            });
            
            // Initialize slider background
            updateSliderBackground(slider);
        }

        // Update slider gradient to show filled portion
        function updateSliderBackground(slider) {
            const min = parseFloat(slider.min) || 0;
            const max = parseFloat(slider.max) || 100;
            const value = parseFloat(slider.value) || 0;
            const percentage = ((value - min) / (max - min)) * 100;
            slider.style.background = `linear-gradient(to right, var(--primary) 0%, var(--primary) ${percentage}%, #e2e8f0 ${percentage}%, #e2e8f0 100%)`;
        }

        // Debounce function for auto-updates
        let updateTimeout;
        function debouncedUpdateCharts() {
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(() => {
                updateCharts();
                updateURLState(); // Update URL after chart update
            }, 300);
        }

        // Update URL with current state (for autosave/sharing)
        function updateURLState() {
            const params = getAllParameters();
            delete params.actualData; // Don't include in URL (too long)
            const urlParams = new URLSearchParams(params);
            const newUrl = window.location.pathname + '?' + urlParams.toString();
            
            // Use replaceState to avoid filling browser history
            window.history.replaceState({}, '', newUrl);
        }

        // Load state from URL parameters on page load
        function loadURLState() {
            const urlParams = new URLSearchParams(window.location.search);
            
            if (urlParams.toString().length === 0) {
                return false; // No URL parameters, use defaults
            }
            
            const params = {};
            const paramNames = [
                'cohortSize', 'timePeriods',
                'shortTermPercent', 'shortTermChurnRate',
                'mediumTermPercent', 'mediumTermChurnRate',
                'longTermPercent', 'longTermChurnRate'
            ];
            
            let hasParams = false;
            paramNames.forEach(name => {
                if (urlParams.has(name)) {
                    params[name] = urlParams.get(name);
                    hasParams = true;
                }
            });
            
            if (hasParams) {
                setAllParameters(params);
                return true;
            }
            
            return false;
        }

        function updateSegmentSum() {
            const shortTerm = parseFloat(document.getElementById('shortTermPercent').value) || 0;
            const mediumTerm = parseFloat(document.getElementById('mediumTermPercent').value) || 0;
            const longTerm = parseFloat(document.getElementById('longTermPercent').value) || 0;
            const total = shortTerm + mediumTerm + longTerm;
            
            const bar = document.getElementById('segmentSumBar');
            const text = document.getElementById('segmentSumText');
            
            const percentage = Math.min(total, 100);
            bar.style.width = percentage + '%';
            text.textContent = total.toFixed(1) + '%';
            
            // Update styling based on total
            bar.classList.remove('valid', 'invalid', 'over');
            if (Math.abs(total - 100) < 0.01) {
                bar.classList.add('valid');
            } else if (total > 100) {
                bar.classList.add('over');
            } else {
                bar.classList.add('invalid');
            }
        }

        // --- Curve Fitting Functions ---
        function toggleFitPanel() {
            const content = document.getElementById('fitContent');
            const icon = document.getElementById('fitToggleIcon');
            content.classList.toggle('visible');
            icon.classList.toggle('expanded');
        }

        function parseRetentionData(input) {
            // Parse input - supports space, comma, or line-separated values
            const values = input
                .split(/[\s,\n]+/)
                .map(v => v.trim())
                .filter(v => v.length > 0)
                .map(v => parseFloat(v));
            
            // Validate
            if (values.length < 4) {
                throw new Error('Need at least 4 data points for fitting');
            }
            if (values.some(v => isNaN(v) || v < 0 || v > 100)) {
                throw new Error('All values must be valid percentages (0-100)');
            }
            if (values[0] !== 100) {
                throw new Error('First value should be 100% (starting cohort)');
            }
            
            // Convert to decimals
            return values.map(v => v / 100);
        }

        function retentionModel(t, params) {
            const [shortTermPct, mediumTermPct, longTermPct, shortTermChurn, mediumTermChurn, longTermChurn] = params;
            return shortTermPct * Math.pow(1 - shortTermChurn, t) + 
                   mediumTermPct * Math.pow(1 - mediumTermChurn, t) + 
                   longTermPct * Math.pow(1 - longTermChurn, t);
        }

        function calculateError(params, data) {
            // Use MAPE (Mean Absolute Percentage Error) instead of SSE
            // MAPE is more robust for different retention patterns and scales
            let mapeSum = 0;
            let count = 0;
            
            for (let t = 0; t < data.length; t++) {
                const predicted = retentionModel(t, params);
                const actual = data[t];
                if (actual > 0.001) { // Avoid division by very small numbers
                    mapeSum += Math.abs((predicted - actual) / actual);
                    count++;
                }
            }
            
            return count > 0 ? mapeSum / count : 1000; // Return large error if no valid points
        }

        function fitModelToData() {
            const resultDiv = document.getElementById('fitResult');
            const input = document.getElementById('retentionData').value;
            
            try {
                // Parse data
                const data = parseRetentionData(input);
                
                // Store actual data for visualization
                actualRetentionData = data;
                
                // Show processing
                resultDiv.className = 'fit-result visible';
                resultDiv.innerHTML = 'üîÑ Fitting model... This may take a few seconds.';
                
                // Run optimization in a timeout to allow UI update
                setTimeout(() => {
                    try {
                        const result = optimizeParameters(data);
                        
                        // Update input fields with fitted parameters
                        document.getElementById('shortTermPercent').value = (result.shortTermPercent * 100).toFixed(1);
                        document.getElementById('shortTermChurnRate').value = (result.shortTermChurn * 100).toFixed(1);
                        document.getElementById('mediumTermPercent').value = (result.mediumTermPercent * 100).toFixed(1);
                        document.getElementById('mediumTermChurnRate').value = (result.mediumTermChurn * 100).toFixed(1);
                        document.getElementById('longTermPercent').value = (result.longTermPercent * 100).toFixed(1);
                        document.getElementById('longTermChurnRate').value = (result.longTermChurn * 100).toFixed(1);
                        
                        // Sync sliders with the fitted values
                        const sliderFields = ['shortTermPercent', 'shortTermChurnRate', 'mediumTermPercent', 
                                              'mediumTermChurnRate', 'longTermPercent', 'longTermChurnRate'];
                        sliderFields.forEach(fieldId => {
                            const slider = document.getElementById(fieldId + 'Slider');
                            const input = document.getElementById(fieldId);
                            if (slider && input) {
                                slider.value = input.value;
                                updateSliderBackground(slider);
                            }
                        });
                        
                        // Update segment sum display
                        updateSegmentSum();
                        
                        // Update churn field states (disable if segment is 0%)
                        updateChurnFieldStates();
                        
                        // Assess fit quality using MAPE (more intuitive than R¬≤)
                        const mape = result.mape;
                        const r2 = result.rSquared;
                        let qualityIcon = '‚úÖ';
                        let qualityText = 'Excellent fit';
                        let qualityClass = 'excellent';
                        let warning = '';
                        
                        if (mape > 10) {
                            qualityIcon = '‚ö†Ô∏è';
                            qualityText = 'Poor fit';
                            qualityClass = 'poor';
                            warning = '<br><br><strong>‚ö†Ô∏è Visual Fit Issue Detected:</strong><br>The model shows significant deviations from your data (avg error: ' + mape.toFixed(1) + '%). Possible reasons:<br>‚Ä¢ Non-exponential decay pattern (S-curves, sudden changes)<br>‚Ä¢ Time-varying churn (seasonal effects)<br>‚Ä¢ Customer reactivation patterns<br><br><strong>Check the light blue dots:</strong> Look for systematic patterns in the errors.';
                        } else if (mape > 5) {
                            qualityIcon = '‚ö°';
                            qualityText = 'Good fit';
                            qualityClass = 'good';
                            warning = '<br><br><em>Note: Minor deviations detected (avg error: ' + mape.toFixed(1) + '%). Visually inspect the light blue dots for any patterns.</em>';
                        }
                        
                        // Show success message with quality assessment
                        resultDiv.className = 'fit-result visible ' + qualityClass;
                        resultDiv.innerHTML = `
                            <strong>${qualityIcon} Model fitted successfully!</strong><br><br>
                            <strong>Short-Term:</strong> ${(result.shortTermPercent * 100).toFixed(1)}%<br>
                            <span style="margin-left: 1rem; opacity: 0.7;">(${(result.shortTermChurn * 100).toFixed(1)}% churn)</span><br>
                            <strong>Medium-Term:</strong> ${(result.mediumTermPercent * 100).toFixed(1)}%<br>
                            <span style="margin-left: 1rem; opacity: 0.7;">(${(result.mediumTermChurn * 100).toFixed(1)}% churn)</span><br>
                            <strong>Long-Term:</strong> ${(result.longTermPercent * 100).toFixed(1)}%<br>
                            <span style="margin-left: 1rem; opacity: 0.7;">(${(result.longTermChurn * 100).toFixed(1)}% churn)</span><br>
                            <br><strong>Avg Error:</strong> ${mape.toFixed(1)}%<br>
                            <span style="margin-left: 1rem; opacity: 0.7;">(${qualityText})</span><br>
                            <strong>R¬≤:</strong> ${r2.toFixed(4)}<br>
                            <span style="margin-left: 1rem; opacity: 0.7;">[${result.method || 'Unknown'}]</span>${warning}
                        `;
                        
                        // Update charts
                        updateCharts();
                        
                        // Update URL with the new fitted parameters
                        updateURLState();
                    } catch (error) {
                        resultDiv.className = 'fit-result visible error';
                        resultDiv.innerHTML = '‚ùå Optimization failed: ' + error.message;
                    }
                }, 100);
                
            } catch (error) {
                resultDiv.className = 'fit-result visible error';
                resultDiv.innerHTML = '‚ùå ' + error.message;
            }
        }

        function optimizeParameters(data) {
            // Multi-method optimization: Run multiple iterations and pick the best result
            // This ensures robust, deterministic fitting even for difficult patterns
            const numIterations = 15; // Run each method multiple times (15 iterations √ó 4 methods = 60 attempts)
            const r2Threshold = 0.999; // Stop if we achieve near-perfect fit
            const allResults = [];
            
            for (let iter = 0; iter < numIterations; iter++) {
                // Method 1: Improved Grid Search + Nelder-Mead
                const gs = optimizeGridSearch(data);
                gs.method = `Grid Search (iter ${iter + 1})`;
                allResults.push(gs);
                
                // Method 2: Differential Evolution
                const de = optimizeDifferentialEvolution(data);
                de.method = `Differential Evolution (iter ${iter + 1})`;
                allResults.push(de);
                
                // Method 3: Random Restart with Nelder-Mead
                const rr = optimizeRandomRestart(data);
                rr.method = `Random Restart (iter ${iter + 1})`;
                allResults.push(rr);
                
                // Method 4: Simulated Annealing
                const sa = optimizeSimulatedAnnealing(data);
                sa.method = `Simulated Annealing (iter ${iter + 1})`;
                allResults.push(sa);
                
                // Check if any result has achieved near-perfect fit
                for (let i = 0; i < allResults.length; i++) {
                    if (allResults[i].rSquared >= r2Threshold) {
                        // Found excellent fit, return it immediately
                        return allResults[i];
                    }
                }
            }
            
            // Select the best result based on error
            let bestResult = allResults[0];
            let bestError = calculateError(
                [bestResult.shortTermPercent, bestResult.mediumTermPercent, bestResult.longTermPercent,
                 bestResult.shortTermChurn, bestResult.mediumTermChurn, bestResult.longTermChurn],
                data
            );
            let bestIndex = 0;
            
            for (let i = 1; i < allResults.length; i++) {
                const error = calculateError(
                    [allResults[i].shortTermPercent, allResults[i].mediumTermPercent, allResults[i].longTermPercent,
                     allResults[i].shortTermChurn, allResults[i].mediumTermChurn, allResults[i].longTermChurn],
                    data
                );
                if (error < bestError) {
                    bestError = error;
                    bestResult = allResults[i];
                    bestIndex = i;
                }
            }
            
            return bestResult;
        }

        function optimizeGridSearch(data) {
            // Original grid search + Nelder-Mead method (improved)
            const firstDrop = 1 - data[1];
            
            let bestParams = [
                Math.min(0.4, firstDrop * 0.8),
                0.4,
                0.2,
                0.95,
                0.10,
                0.01
            ];
            
            const segmentSum = bestParams[0] + bestParams[1] + bestParams[2];
            bestParams[0] /= segmentSum;
            bestParams[1] /= segmentSum;
            bestParams[2] /= segmentSum;
            
            let bestError = calculateError(bestParams, data);
            
            // Expanded grid search with more diverse churn rate combinations
            // This helps find better fits for non-standard patterns like S-curves
            for (let tp = 0; tp <= 0.7; tp += 0.1) {
                for (let mp = 0; mp <= 0.7; mp += 0.1) {
                    const lp = 1 - tp - mp;
                    if (lp < 0 || lp > 1) continue;
                    
                    // Try wider range of churn combinations
                    for (let tc = 0.5; tc <= 0.99; tc += 0.1) {
                        for (let mc = 0.01; mc <= 0.50; mc += 0.08) {
                            for (let lc = 0; lc <= 0.20; lc += 0.04) {
                                const params = [tp, mp, lp, tc, mc, lc];
                                const error = calculateError(params, data);
                                if (error < bestError) {
                                    bestError = error;
                                    bestParams = [...params];
                                }
                            }
                        }
                    }
                }
            }
            
            const result = nelderMead(bestParams, data);
            return formatOptimizationResult(result.params, data);
        }

        function optimizeDifferentialEvolution(data) {
            // Differential Evolution: Global optimization algorithm
            const popSize = 40; // Increased from 30 for better exploration
            const maxGen = 150; // Increased from 100 for more convergence
            const F = 0.8;  // Differential weight
            const CR = 0.9; // Crossover probability
            const bounds = [
                [0, 1], [0, 1], [0, 1],  // segment percentages
                [0.5, 0.99], [0.01, 0.5], [0, 0.1]  // churn rates
            ];
            
            // Initialize population
            let population = [];
            for (let i = 0; i < popSize; i++) {
                const individual = [
                    Math.random(), Math.random(), Math.random(),
                    0.5 + Math.random() * 0.49,
                    0.01 + Math.random() * 0.49,
                    Math.random() * 0.1
                ];
                // Normalize segments
                const sum = individual[0] + individual[1] + individual[2];
                individual[0] /= sum;
                individual[1] /= sum;
                individual[2] /= sum;
                population.push(individual);
            }
            
            // Evolution
            for (let gen = 0; gen < maxGen; gen++) {
                for (let i = 0; i < popSize; i++) {
                    // Select three random individuals (different from i)
                    const indices = [];
                    while (indices.length < 3) {
                        const idx = Math.floor(Math.random() * popSize);
                        if (idx !== i && !indices.includes(idx)) {
                            indices.push(idx);
                        }
                    }
                    
                    // Mutation: v = a + F * (b - c)
                    const trial = [];
                    for (let j = 0; j < 6; j++) {
                        if (Math.random() < CR || j === Math.floor(Math.random() * 6)) {
                            let value = population[indices[0]][j] + F * (population[indices[1]][j] - population[indices[2]][j]);
                            // Clamp to bounds
                            value = Math.max(bounds[j][0], Math.min(bounds[j][1], value));
                            trial.push(value);
                        } else {
                            trial.push(population[i][j]);
                        }
                    }
                    
                    // Normalize segments
                    const sum = trial[0] + trial[1] + trial[2];
                    trial[0] /= sum;
                    trial[1] /= sum;
                    trial[2] /= sum;
                    
                    // Selection: Keep if better
                    if (calculateError(trial, data) < calculateError(population[i], data)) {
                        population[i] = trial;
                    }
                }
            }
            
            // Find best individual
            let bestParams = population[0];
            let bestError = calculateError(bestParams, data);
            for (let i = 1; i < popSize; i++) {
                const error = calculateError(population[i], data);
                if (error < bestError) {
                    bestError = error;
                    bestParams = population[i];
                }
            }
            
            // Refine with Nelder-Mead
            const result = nelderMead(bestParams, data, 100);
            return formatOptimizationResult(result.params, data);
        }

        function optimizeRandomRestart(data) {
            // Random restart: Try multiple random starting points with Nelder-Mead
            const numRestarts = 25; // Increased from 15 for better exploration
            let bestResult = null;
            let bestError = Infinity;
            
            for (let i = 0; i < numRestarts; i++) {
                // Random initial parameters
                const tp = Math.random() * 0.6;
                const mp = Math.random() * (1 - tp);
                const lp = 1 - tp - mp;
                
                const initialParams = [
                    tp, mp, lp,
                    0.5 + Math.random() * 0.49,  // shortTermChurn: 0.5-0.99
                    0.01 + Math.random() * 0.49,  // mediumTermChurn: 0.01-0.5
                    Math.random() * 0.1           // longTermChurn: 0-0.1
                ];
                
                const result = nelderMead(initialParams, data, 150);
                const error = result.error;
                
                if (error < bestError) {
                    bestError = error;
                    bestResult = result.params;
                }
            }
            
            return formatOptimizationResult(bestResult, data);
        }

        function optimizeSimulatedAnnealing(data) {
            // Simulated Annealing: Probabilistic optimization that can escape local minima
            const maxIterations = 2000;
            let temperature = 1.0;
            const coolingRate = 0.995;
            const minTemperature = 0.001;
            
            // Random initial state
            let tp = Math.random() * 0.6;
            let mp = Math.random() * (1 - tp);
            let lp = 1 - tp - mp;
            
            let currentState = [
                tp, mp, lp,
                0.5 + Math.random() * 0.49,  // shortTermChurn
                0.01 + Math.random() * 0.49,  // mediumTermChurn
                Math.random() * 0.1           // longTermChurn
            ];
            
            let currentEnergy = calculateError(currentState, data);
            let bestState = [...currentState];
            let bestEnergy = currentEnergy;
            
            for (let iter = 0; iter < maxIterations && temperature > minTemperature; iter++) {
                // Generate neighbor by perturbing current state
                const neighbor = currentState.map((val, idx) => {
                    const perturbation = (Math.random() - 0.5) * 0.1 * temperature;
                    let newVal = val + perturbation;
                    
                    // Apply bounds
                    if (idx < 3) {
                        newVal = Math.max(0, Math.min(1, newVal));
                    } else if (idx === 3) {
                        newVal = Math.max(0.5, Math.min(0.99, newVal));
                    } else if (idx === 4) {
                        newVal = Math.max(0.01, Math.min(0.5, newVal));
                    } else {
                        newVal = Math.max(0, Math.min(0.1, newVal));
                    }
                    
                    return newVal;
                });
                
                // Normalize segments
                const sum = neighbor[0] + neighbor[1] + neighbor[2];
                neighbor[0] /= sum;
                neighbor[1] /= sum;
                neighbor[2] /= sum;
                
                const neighborEnergy = calculateError(neighbor, data);
                const deltaE = neighborEnergy - currentEnergy;
                
                // Accept neighbor if better, or with probability based on temperature
                if (deltaE < 0 || Math.random() < Math.exp(-deltaE / temperature)) {
                    currentState = neighbor;
                    currentEnergy = neighborEnergy;
                    
                    // Update best if improved
                    if (currentEnergy < bestEnergy) {
                        bestState = [...currentState];
                        bestEnergy = currentEnergy;
                    }
                }
                
                // Cool down
                temperature *= coolingRate;
            }
            
            // Final refinement with Nelder-Mead
            const result = nelderMead(bestState, data, 100);
            return formatOptimizationResult(result.params, data);
        }

        function formatOptimizationResult(params, data) {
            // Normalize segments to sum to 100%
            let shortTermPct = Math.max(0, params[0]);
            let mediumTermPct = Math.max(0, params[1]);
            let longTermPct = Math.max(0, params[2]);
            const total = shortTermPct + mediumTermPct + longTermPct;
            
            let normalizedParams = [
                shortTermPct / total,
                mediumTermPct / total,
                longTermPct / total,
                Math.max(0, Math.min(0.99, params[3])),
                Math.max(0.001, Math.min(0.99, params[4])),
                Math.max(0, Math.min(0.99, params[5]))
            ];
            
            // Sort segments by churn rate (highest to lowest) to ensure proper naming
            // This ensures short-term has highest churn, medium-term has middle, long-term has lowest
            // Filter out segments with near-zero percentage first
            const threshold = 0.001; // 0.1% threshold - only filter truly negligible segments
            const segments = [
                { pct: normalizedParams[0], churn: normalizedParams[3], index: 0 },
                { pct: normalizedParams[1], churn: normalizedParams[4], index: 1 },
                { pct: normalizedParams[2], churn: normalizedParams[5], index: 2 }
            ];
            
            // Count non-zero segments
            const nonZeroSegments = segments.filter(s => s.pct >= threshold);
            
            if (nonZeroSegments.length === 1) {
                // Single dominant segment - assign to long-term (lowest churn) for asymptote calculation
                normalizedParams = [
                    0,                        // short-term
                    0,                        // medium-term
                    nonZeroSegments[0].pct,   // long-term gets all
                    0.99,                     // short-term churn (not used)
                    0.50,                     // medium-term churn (not used)
                    nonZeroSegments[0].churn  // long-term churn
                ];
            } else if (nonZeroSegments.length === 2) {
                // Two segments - assign to short and long, leave medium at 0
                nonZeroSegments.sort((a, b) => b.churn - a.churn);
                normalizedParams = [
                    nonZeroSegments[0].pct,   // highest churn -> short-term
                    0,                        // medium-term
                    nonZeroSegments[1].pct,   // lowest churn -> long-term
                    nonZeroSegments[0].churn, // short-term churn
                    0.50,                     // medium-term churn (not used)
                    nonZeroSegments[1].churn  // long-term churn
                ];
            } else {
                // Three segments - normal sorting
                segments.sort((a, b) => b.churn - a.churn);
                normalizedParams = [
                    segments[0].pct,    // highest churn -> short-term
                    segments[1].pct,    // middle churn -> medium-term
                    segments[2].pct,    // lowest churn -> long-term
                    segments[0].churn,  // short-term churn
                    segments[1].churn,  // medium-term churn
                    segments[2].churn   // long-term churn
                ];
            }
            
            // Generate predicted values
            const predicted = data.map((_, i) => {
                const t = i;
                const shortTerm = normalizedParams[0] * Math.pow(1 - normalizedParams[3], t);
                const mediumTerm = normalizedParams[1] * Math.pow(1 - normalizedParams[4], t);
                const longTerm = normalizedParams[2] * Math.pow(1 - normalizedParams[5], t);
                return (shortTerm + mediumTerm + longTerm);
            });
            
            // Calculate R¬≤
            const n = data.length;
            const meanActual = data.reduce((sum, val) => sum + val, 0) / n;
            let ssRes = 0;
            let ssTot = 0;
            for (let i = 0; i < n; i++) {
                ssRes += Math.pow(data[i] - predicted[i], 2);
                ssTot += Math.pow(data[i] - meanActual, 2);
            }
            const rSquared = (ssTot === 0) ? 1 : (1 - (ssRes / ssTot));
            
            // Calculate MAPE
            let mapeSum = 0;
            let mapeCount = 0;
            for (let i = 0; i < data.length; i++) {
                if (data[i] !== 0) {
                    mapeSum += Math.abs((data[i] - predicted[i]) / data[i]);
                    mapeCount++;
                }
            }
            const mape = (mapeCount > 0) ? (mapeSum / mapeCount) * 100 : 0;
            
            return {
                shortTermPercent: normalizedParams[0],
                mediumTermPercent: normalizedParams[1],
                longTermPercent: normalizedParams[2],
                shortTermChurn: normalizedParams[3],
                mediumTermChurn: normalizedParams[4],
                longTermChurn: normalizedParams[5],
                rSquared: rSquared,
                mape: mape
            };
        }

        function nelderMead(initialParams, data, maxIterations = 200) {
            const alpha = 1.0;  // Reflection
            const gamma = 2.0;  // Expansion
            const rho = 0.5;    // Contraction
            const sigma = 0.5;  // Shrink
            
            // Create initial simplex
            const n = initialParams.length;
            let simplex = [initialParams];
            
            for (let i = 0; i < n; i++) {
                const point = [...initialParams];
                point[i] += 0.05; // Small perturbation
                simplex.push(point);
            }
            
            // Evaluate simplex
            let errors = simplex.map(p => calculateError(p, data));
            
            for (let iter = 0; iter < maxIterations; iter++) {
                // Sort by error
                const indices = errors.map((e, i) => i).sort((a, b) => errors[a] - errors[b]);
                simplex = indices.map(i => simplex[i]);
                errors = indices.map(i => errors[i]);
                
                // Check convergence
                if (errors[n] - errors[0] < 1e-8) break;
                
                // Calculate centroid (excluding worst point)
                const centroid = new Array(n).fill(0);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        centroid[j] += simplex[i][j];
                    }
                }
                for (let j = 0; j < n; j++) {
                    centroid[j] /= n;
                }
                
                // Reflection
                const reflected = centroid.map((c, i) => c + alpha * (c - simplex[n][i]));
                const reflectedError = calculateError(reflected, data);
                
                if (reflectedError < errors[0]) {
                    // Expansion
                    const expanded = centroid.map((c, i) => c + gamma * (reflected[i] - c));
                    const expandedError = calculateError(expanded, data);
                    
                    if (expandedError < reflectedError) {
                        simplex[n] = expanded;
                        errors[n] = expandedError;
                    } else {
                        simplex[n] = reflected;
                        errors[n] = reflectedError;
                    }
                } else if (reflectedError < errors[n - 1]) {
                    simplex[n] = reflected;
                    errors[n] = reflectedError;
                } else {
                    // Contraction
                    const contracted = centroid.map((c, i) => c + rho * (simplex[n][i] - c));
                    const contractedError = calculateError(contracted, data);
                    
                    if (contractedError < errors[n]) {
                        simplex[n] = contracted;
                        errors[n] = contractedError;
                    } else {
                        // Shrink
                        for (let i = 1; i <= n; i++) {
                            simplex[i] = simplex[0].map((s0, j) => s0 + sigma * (simplex[i][j] - s0));
                            errors[i] = calculateError(simplex[i], data);
                        }
                    }
                }
            }
            
            return { params: simplex[0], error: errors[0] };
        }

        const retentionCtx = document.getElementById('retentionChart').getContext('2d');
        const growthCtx = document.getElementById('growthChart').getContext('2d');
        
        const retentionChart = new Chart(retentionCtx, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        align: 'center',
                        labels: { 
                            boxWidth: 12, 
                            usePointStyle: true
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                // Round to nearest whole number for user counts
                                label += Math.round(context.parsed.y).toLocaleString();
                                return label;
                            }
                        }
                    },
                    annotation: { annotations: {} }
                },
                scales: {
                    x: {
                        title: { display: true, text: 'Months Since Acqusition', font: { weight: 500 } },
                        grid: { display: false },
                        ticks: { color: '#64748b' },
                        border: { color: '#cbd5e1' }
                    },
                    y: {
                        beginAtZero: true,
                        stacked: true,
                        title: { display: true, text: 'Users Remaining', font: { weight: 500 } },
                        ticks: { color: '#64748b' },
                        border: { color: '#cbd5e1' }
                    }
                }
            }
        });
        
        const growthChart = new Chart(growthCtx, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                plugins: {
                    legend: {
                        position: 'bottom',
                        align: 'center',
                        labels: { 
                            boxWidth: 12, 
                            usePointStyle: true
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                // Round to nearest whole number for user counts
                                label += Math.round(context.parsed.y).toLocaleString();
                                return label;
                            }
                        }
                    },
                    annotation: { annotations: {} }
                },
                scales: {
                    x: {
                        title: { display: true, text: 'Months Passed', font: { weight: 500 } },
                        grid: { display: false },
                        ticks: { color: '#64748b' },
                        border: { color: '#cbd5e1' }
                    },
                    y: {
                        beginAtZero: true,
                        stacked: true,
                        title: { display: true, text: 'Total Active Customers', font: { weight: 500 } },
                        ticks: { color: '#64748b' },
                        border: { color: '#cbd5e1' }
                    }
                }
            }
        });

        function updateCharts() {
            // Get input values
            const shortTermPercent = parseFloat(document.getElementById('shortTermPercent').value) / 100;
            const shortTermChurn = parseFloat(document.getElementById('shortTermChurnRate').value) / 100;
            const mediumTermPercent = parseFloat(document.getElementById('mediumTermPercent').value) / 100;
            const mediumTermChurn = parseFloat(document.getElementById('mediumTermChurnRate').value) / 100;
            const longTermPercent = parseFloat(document.getElementById('longTermPercent').value) / 100;
            const longTermChurn = parseFloat(document.getElementById('longTermChurnRate').value) / 100;
            const cohortSize = parseFloat(document.getElementById('cohortSize').value);
            const timePeriods = parseInt(document.getElementById('timePeriods').value);

            // Simple validation
            if ([shortTermPercent, shortTermChurn, mediumTermPercent, mediumTermChurn, longTermPercent, longTermChurn, cohortSize, timePeriods].some(isNaN)) {
                return; // Silently skip update if invalid
            }

            // Validate that segment percentages sum to 100% (allow 99-101% range)
            const segmentSum = shortTermPercent + mediumTermPercent + longTermPercent;
            if (segmentSum < 0.99 || segmentSum > 1.01) {
                return; // Silently skip update if segments don't sum to 100%
            }

            const T = cohortSize * shortTermPercent;
            const M = cohortSize * mediumTermPercent;
            const L = cohortSize * longTermPercent;
            const timePoints = Array.from({ length: timePeriods + 1 }, (_, i) => i);

            // --- RETENTION CALCULATION (3-segment model) ---
            const retentionData = timePoints.map(t => {
                let shortTermRem = (shortTermChurn === 1) ? (t === 0 ? T : 0) : T * Math.pow(1 - shortTermChurn, t);
                let transRem = (mediumTermChurn === 1) ? (t === 0 ? M : 0) : M * Math.pow(1 - mediumTermChurn, t);
                let longTermRem = (longTermChurn === 1) ? (t === 0 ? L : 0) : L * Math.pow(1 - longTermChurn, t);
                return shortTermRem + transRem + longTermRem;
            });

            // Calculate individual segment data for stacked area chart
            const shortTermData = timePoints.map(t => {
                return (shortTermChurn === 1) ? (t === 0 ? T : 0) : T * Math.pow(1 - shortTermChurn, t);
            });
            const mediumTermData = timePoints.map(t => {
                return (mediumTermChurn === 1) ? (t === 0 ? M : 0) : M * Math.pow(1 - mediumTermChurn, t);
            });
            const longTermData = timePoints.map(t => {
                return (longTermChurn === 1) ? (t === 0 ? L : 0) : L * Math.pow(1 - longTermChurn, t);
            });

            // --- KPI CALCS: MEDIAN & MEAN ---
            let medianLifetimeStr = 'Infinite';
            let medianLifetime = Infinity;
            const halfCohort = cohortSize / 2;

            if (retentionData[timePeriods] < halfCohort) {
                 // Find where it crosses 50%
                 for (let i = 0; i < timePeriods; i++) {
                    if (retentionData[i] >= halfCohort && retentionData[i+1] < halfCohort) {
                        // Linear interpolation for smoother display
                        const slope = retentionData[i+1] - retentionData[i];
                        medianLifetime = i + (halfCohort - retentionData[i]) / slope;
                        medianLifetimeStr = medianLifetime.toFixed(1) + ' mo';
                        break;
                    }
                 }
            } else if (mediumTermChurn > 0 || longTermChurn > 0) {
                 medianLifetimeStr = '> ' + timePeriods + ' mo';
            }

            let meanLifetime = Infinity;
            if (shortTermChurn > 0 && mediumTermChurn > 0 && longTermChurn > 0) {
                // Weighted average of segment lifetimes
                meanLifetime = (shortTermPercent / shortTermChurn) + (mediumTermPercent / mediumTermChurn) + (longTermPercent / longTermChurn);
                document.getElementById('meanDisplay').innerText = meanLifetime.toFixed(1) + ' mo';
            } else {
                document.getElementById('meanDisplay').innerText = 'Infinite';
            }
            document.getElementById('medianDisplay').innerText = medianLifetimeStr;

            // --- SEGMENT-SPECIFIC METRICS ---
            // Display individual segment metrics if more than one segment is active
            const segmentHalfLivesDiv = document.getElementById('segmentHalfLives');
            const segmentMeansDiv = document.getElementById('segmentMeans');
            const activeSegments = [
                { name: 'Short-Term', percent: shortTermPercent, churn: shortTermChurn },
                { name: 'Medium-Term', percent: mediumTermPercent, churn: mediumTermChurn },
                { name: 'Long-Term', percent: longTermPercent, churn: longTermChurn }
            ].filter(seg => seg.percent > 0.001); // Only include segments with >0.1%

            if (activeSegments.length > 1) {
                const halfLives = activeSegments.map(seg => {
                    // Calculate half-life: t where remaining = initial/2
                    // For exponential decay: 0.5 = (1-churn)^t, so t = ln(0.5)/ln(1-churn)
                    if (seg.churn > 0 && seg.churn < 1) {
                        return (Math.log(0.5) / Math.log(1 - seg.churn)).toFixed(1) + ' mo';
                    } else if (seg.churn === 1) {
                        return '0 mo';
                    }
                    return '‚àû';
                });
                
                const means = activeSegments.map(seg => {
                    // Mean lifetime = 1/churn (for exponential decay)
                    if (seg.churn > 0) {
                        return (1 / seg.churn).toFixed(1) + ' mo';
                    }
                    return '‚àû';
                });
                
                segmentHalfLivesDiv.innerHTML = '(' + halfLives.join(', ') + ')';
                segmentHalfLivesDiv.style.display = 'block';
                
                segmentMeansDiv.innerHTML = '(' + means.join(', ') + ')';
                segmentMeansDiv.style.display = 'block';
            } else {
                segmentHalfLivesDiv.style.display = 'none';
                segmentMeansDiv.style.display = 'none';
            }

            // --- GROWTH CALCULATION (3-segment model) ---
             const growthData = timePoints.map(t => {
                // Sum of all cohorts up to time t (each with 3 segments)
                let total = 0;
                for (let k = 0; k <= t; k++) {
                    const age = t - k;
                    total += (T * Math.pow(1 - shortTermChurn, age)) + 
                             (M * Math.pow(1 - mediumTermChurn, age)) + 
                             (L * Math.pow(1 - longTermChurn, age));
                }
                return total;
            });

            // Calculate segment-specific growth data for stacking
            const shortTermGrowthData = timePoints.map(t => {
                let total = 0;
                for (let k = 0; k <= t; k++) {
                    const age = t - k;
                    total += T * Math.pow(1 - shortTermChurn, age);
                }
                return total;
            });

            const mediumTermGrowthData = timePoints.map(t => {
                let total = 0;
                for (let k = 0; k <= t; k++) {
                    const age = t - k;
                    total += M * Math.pow(1 - mediumTermChurn, age);
                }
                return total;
            });

            const longTermGrowthData = timePoints.map(t => {
                let total = 0;
                for (let k = 0; k <= t; k++) {
                    const age = t - k;
                    total += L * Math.pow(1 - longTermChurn, age);
                }
                return total;
            });

            // --- KPI CALCS: ASYMPTOTE ---
            let asymptoteStr = 'No Ceiling (Linear Growth)';
            let isLinear = (shortTermChurn === 0 || mediumTermChurn === 0 || longTermChurn === 0);
            let asymptoteVal = null;
            let linearAsymptoteData = null;

            if (!isLinear) {
                // All segments have churn - finite asymptote
                asymptoteVal = (T / shortTermChurn) + (M / mediumTermChurn) + (L / longTermChurn);
                asymptoteStr = Math.round(asymptoteVal).toLocaleString();
                document.getElementById('asymptoteFormula').innerText = 'Your growth will level off here without improving retention or acquisition';
            } else {
                document.getElementById('asymptoteFormula').innerText = 'No ceiling - at least one segment has 0% churn (infinite retention)';
                
                // Calculate linear asymptote - sum up the segments
                linearAsymptoteData = timePoints.map(t => {
                    let asymptote = 0;
                    
                    // shortTerm contribution
                    if (shortTermChurn === 0) {
                        asymptote += T * (t + 1); // Linear growth
                    } else {
                        asymptote += T / shortTermChurn; // Steady state
                    }
                    
                    // mediumTerm contribution
                    if (mediumTermChurn === 0) {
                        asymptote += M * (t + 1); // Linear growth
                    } else {
                        asymptote += M / mediumTermChurn; // Steady state
                    }
                    
                    // longTerm contribution
                    if (longTermChurn === 0) {
                        asymptote += L * (t + 1); // Linear growth
                    } else {
                        asymptote += L / longTermChurn; // Steady state
                    }
                    
                    return asymptote;
                });
                
                const growingSegments = [];
                if (shortTermChurn === 0) growingSegments.push(`${T.toFixed(0)} (short-term)`);
                if (mediumTermChurn === 0) growingSegments.push(`${M.toFixed(0)} (medium-term)`);
                if (longTermChurn === 0) growingSegments.push(`${L.toFixed(0)} (long-term)`);
                
                // Calculate steady-state contribution from segments with churn
                let steadyState = 0;
                if (shortTermChurn > 0) steadyState += T / shortTermChurn;
                if (mediumTermChurn > 0) steadyState += M / mediumTermChurn;
                if (longTermChurn > 0) steadyState += L / longTermChurn;
                
                asymptoteStr = `Linear: ${growingSegments.join(' + ')} √ó (t + 1) + ${Math.round(steadyState).toLocaleString()}`;
            }
            document.getElementById('asymptoteDisplay').innerText = asymptoteStr;


            // --- UPDATE CHARTS ---
            
            // Get theme-aware colors
            const chartColors = getChartColors();
            
            // 1. Retention Update - Stacked areas for each segment
            const retentionDatasets = [];
            
            // Only add segments that have data (non-zero percentage)
            if (longTermPercent > 0) {
                retentionDatasets.push({
                    label: 'Long-term Segment',
                    data: longTermData,
                    borderColor: chartColors.longTerm.border,
                    backgroundColor: chartColors.longTerm.background,
                    borderWidth: 0,
                    pointRadius: 0,
                    pointHoverRadius: 4,
                    fill: true,
                    stack: 'segments',
                    order: 4
                });
            }
            
            if (mediumTermPercent > 0) {
                retentionDatasets.push({
                    label: 'Medium-term Segment',
                    data: mediumTermData,
                    borderColor: chartColors.mediumTerm.border,
                    backgroundColor: chartColors.mediumTerm.background,
                    borderWidth: 0,
                    pointRadius: 0,
                    pointHoverRadius: 4,
                    fill: true,
                    stack: 'segments',
                    order: 3
                });
            }
            
            if (shortTermPercent > 0) {
                retentionDatasets.push({
                    label: 'Short-term Segment',
                    data: shortTermData,
                    borderColor: chartColors.shortTerm.border,
                    backgroundColor: chartColors.shortTerm.background,
                    borderWidth: 0,
                    pointRadius: 0,
                    pointHoverRadius: 4,
                    fill: true,
                    stack: 'segments',
                    order: 2
                });
            }
            
            // Always add the total retention line
            retentionDatasets.push({
                label: 'Total Retention',
                data: retentionData,
                borderColor: chartColors.totalLine,
                backgroundColor: 'transparent',
                borderWidth: 2.5,
                pointRadius: 0,
                pointHoverRadius: 6,
                fill: false,
                order: 1,
                tension: 0.1,
                stack: 'total-line',  // Separate stack to prevent contribution to stacked areas
                yAxisID: 'y'
            });
            
            // Add actual data points if they exist (from curve fitting)
            if (actualRetentionData && actualRetentionData.length > 0) {
                // Convert actual data to absolute numbers (multiply by cohort size)
                const actualPoints = actualRetentionData.map(pct => pct * cohortSize);
                
                retentionDatasets.push({
                    label: 'Actual Data',
                    data: actualPoints,
                    type: 'scatter',
                    borderColor: chartColors.actualData,
                    backgroundColor: chartColors.actualData,
                    pointRadius: 5,
                    pointHoverRadius: 7,
                    borderWidth: 2,
                    showLine: false,
                    order: 0
                });
            }
            
            retentionChart.data = {
                labels: timePoints,
                datasets: retentionDatasets
            };

            // Retention Annotations (Median and Mean lines)
            retentionChart.options.plugins.annotation.annotations = {};
            if (isFinite(medianLifetime) && medianLifetime <= timePeriods) {
                 retentionChart.options.plugins.annotation.annotations.medianLine = {
                    type: 'line',
                    xMin: medianLifetime,
                    xMax: medianLifetime,
                    borderColor: '#ef4444',
                    borderWidth: 2,
                    borderDash: [4, 4],
                    label: { display: true, content: 'Median', position: 'end', backgroundColor: '#ef4444', font: {size: 10} }
                 };
            }
            if (isFinite(meanLifetime) && meanLifetime >= 0 && meanLifetime <= timePeriods) {
                 retentionChart.options.plugins.annotation.annotations.meanLine = {
                    type: 'line',
                    xMin: meanLifetime,
                    xMax: meanLifetime,
                    borderColor: '#f97316',
                    borderWidth: 2,
                    borderDash: [6, 3],
                    label: { display: true, content: 'Mean', position: 'start', backgroundColor: '#f97316', font: {size: 10} }
                 };
            }
            retentionChart.update();

            // 2. Growth Update - Stacked areas for each segment
            const datasets = [];
            
            // Only add segments that have data (non-zero percentage)
            if (longTermPercent > 0) {
                datasets.push({
                    label: 'Long-term Segment',
                    data: longTermGrowthData,
                    borderColor: chartColors.longTerm.border,
                    backgroundColor: chartColors.longTerm.background,
                    borderWidth: 0,
                    pointRadius: 0,
                    pointHoverRadius: 4,
                    fill: true,
                    stack: 'segments',
                    order: 4
                });
            }
            
            if (mediumTermPercent > 0) {
                datasets.push({
                    label: 'Medium-term Segment',
                    data: mediumTermGrowthData,
                    borderColor: chartColors.mediumTerm.border,
                    backgroundColor: chartColors.mediumTerm.background,
                    borderWidth: 0,
                    pointRadius: 0,
                    pointHoverRadius: 4,
                    fill: true,
                    stack: 'segments',
                    order: 3
                });
            }
            
            if (shortTermPercent > 0) {
                datasets.push({
                    label: 'Short-term Segment',
                    data: shortTermGrowthData,
                    borderColor: chartColors.shortTerm.border,
                    backgroundColor: chartColors.shortTerm.background,
                    borderWidth: 0,
                    pointRadius: 0,
                    pointHoverRadius: 4,
                    fill: true,
                    stack: 'segments',
                    order: 2
                });
            }
            
            // Always add the total line
            datasets.push({
                label: 'Total Customers',
                data: growthData,
                borderColor: chartColors.totalLine,
                backgroundColor: 'transparent',
                borderWidth: 2.5,
                pointRadius: 0,
                pointHoverRadius: 6,
                fill: false,
                order: 1,
                tension: 0.1,
                stack: 'total-line'
            });
            
            // Add linear asymptote as a separate dataset if it exists
            if (linearAsymptoteData) {
                datasets.push({
                    label: 'Linear Asymptote',
                    data: linearAsymptoteData,
                    borderColor: '#a855f7',
                    borderWidth: 2,
                    borderDash: [8, 4],
                    fill: false,
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    stack: 'asymptote-line',
                    order: 0
                });
            }
            
            growthChart.data = {
                labels: timePoints,
                datasets: datasets
            };

            // Growth Annotations (Asymptote)
            growthChart.options.plugins.annotation.annotations = {};
            if (asymptoteVal !== null) {
                 growthChart.options.plugins.annotation.annotations.ceilingLine = {
                    type: 'line',
                    yMin: asymptoteVal,
                    yMax: asymptoteVal,
                    borderColor: '#ef4444', // Red for ceiling
                    borderWidth: 1,
                    borderDash: [6, 6],
                    label: { display: true, content: 'Ceiling', position: 'end', backgroundColor: 'rgba(239, 68, 68, 0.8)', font: {size: 10} }
                 };
                 // Ensure y-axis can see the asymptote if it's close
                 growthChart.options.scales.y.suggestedMax = Math.max(growthData[timePeriods] * 1.1, asymptoteVal * 1.05);
            } else {
                growthChart.options.scales.y.suggestedMax = undefined;
            }

            growthChart.update();
        }

        // Help Modal Functions
        function toggleHelp() {
            const modal = document.getElementById('helpModal');
            modal.classList.toggle('active');
        }

        function closeHelpIfClickOutside(event) {
            if (event.target.id === 'helpModal') {
                toggleHelp();
            }
        }

        // Theme toggle functionality
        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            
            // Update icon
            const icon = document.getElementById('themeIcon');
            icon.textContent = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
            
            // Update chart colors
            updateChartColors();
        }

        // Load saved theme on page load
        function loadTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            const html = document.documentElement;
            html.setAttribute('data-theme', savedTheme);
            
            // Update icon
            const icon = document.getElementById('themeIcon');
            if (icon) {
                icon.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
            }
            
            // Update chart colors
            updateChartColors();
        }

        // Keyboard support for help modal
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const modal = document.getElementById('helpModal');
                if (modal.classList.contains('active')) {
                    toggleHelp();
                }
            }
            // Press Enter anywhere in the controls panel to update charts
            if (event.key === 'Enter' && event.target.tagName === 'INPUT') {
                updateCharts();
            }
        });

        // --- Presets ---
        const PRESETS = {
            saas: {
                name: "SaaS Startup",
                cohortSize: "1000",
                timePeriods: "36",
                shortTermPercent: "30.0",
                shortTermChurnRate: "85.0",
                mediumTermPercent: "50.0",
                mediumTermChurnRate: "12.0",
                longTermPercent: "20.0",
                longTermChurnRate: "2.0"
            },
            ecommerce: {
                name: "E-commerce",
                cohortSize: "2000",
                timePeriods: "24",
                shortTermPercent: "40.0",
                shortTermChurnRate: "70.0",
                mediumTermPercent: "45.0",
                mediumTermChurnRate: "15.0",
                longTermPercent: "15.0",
                longTermChurnRate: "5.0"
            },
            mobile: {
                name: "Mobile App",
                cohortSize: "5000",
                timePeriods: "12",
                shortTermPercent: "75.0",
                shortTermChurnRate: "95.0",
                mediumTermPercent: "20.0",
                mediumTermChurnRate: "25.0",
                longTermPercent: "5.0",
                longTermChurnRate: "8.0"
            },
            enterprise: {
                name: "Enterprise B2B",
                cohortSize: "50",
                timePeriods: "60",
                shortTermPercent: "10.0",
                shortTermChurnRate: "50.0",
                mediumTermPercent: "40.0",
                mediumTermChurnRate: "5.0",
                longTermPercent: "50.0",
                longTermChurnRate: "1.0"
            }
        };

        // --- Export & Share Functions ---
        
        function downloadRetentionChart() {
            const canvas = document.getElementById('retentionChart');
            const url = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'retention-chart.png';
            link.href = url;
            link.click();
        }

        function downloadGrowthChart() {
            const canvas = document.getElementById('growthChart');
            const url = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'growth-chart.png';
            link.href = url;
            link.click();
        }

        function getAllParameters() {
            return {
                cohortSize: document.getElementById('cohortSize').value,
                timePeriods: document.getElementById('timePeriods').value,
                shortTermPercent: document.getElementById('shortTermPercent').value,
                shortTermChurnRate: document.getElementById('shortTermChurnRate').value,
                mediumTermPercent: document.getElementById('mediumTermPercent').value,
                mediumTermChurnRate: document.getElementById('mediumTermChurnRate').value,
                longTermPercent: document.getElementById('longTermPercent').value,
                longTermChurnRate: document.getElementById('longTermChurnRate').value,
                actualData: actualRetentionData // Include fitted data if exists
            };
        }

        function setAllParameters(params) {
            if (params.cohortSize) document.getElementById('cohortSize').value = params.cohortSize;
            if (params.timePeriods) document.getElementById('timePeriods').value = params.timePeriods;
            if (params.shortTermPercent) document.getElementById('shortTermPercent').value = params.shortTermPercent;
            if (params.shortTermChurnRate) document.getElementById('shortTermChurnRate').value = params.shortTermChurnRate;
            if (params.mediumTermPercent) document.getElementById('mediumTermPercent').value = params.mediumTermPercent;
            if (params.mediumTermChurnRate) document.getElementById('mediumTermChurnRate').value = params.mediumTermChurnRate;
            if (params.longTermPercent) document.getElementById('longTermPercent').value = params.longTermPercent;
            if (params.longTermChurnRate) document.getElementById('longTermChurnRate').value = params.longTermChurnRate;
            
            // Sync sliders with loaded values
            const sliderFields = ['shortTermPercent', 'shortTermChurnRate', 'mediumTermPercent', 
                                  'mediumTermChurnRate', 'longTermPercent', 'longTermChurnRate'];
            sliderFields.forEach(fieldId => {
                if (params[fieldId]) {
                    const slider = document.getElementById(fieldId + 'Slider');
                    if (slider) {
                        slider.value = params[fieldId];
                        updateSliderBackground(slider);
                    }
                }
            });
            
            // Update segment sum display
            updateSegmentSum();
            
            // Restore actual retention data if it was saved
            if (params.actualData) {
                actualRetentionData = params.actualData;
            }
        }

        function copyShareableLink() {
            const params = getAllParameters();
            delete params.actualData; // Don't include in URL (too long)
            const urlParams = new URLSearchParams(params);
            const shareUrl = window.location.origin + window.location.pathname + '?' + urlParams.toString();
            
            navigator.clipboard.writeText(shareUrl).then(() => {
                alert('‚úÖ Link copied to clipboard! Share this URL to let others view your simulation.');
            }).catch(() => {
                // Fallback for older browsers
                prompt('Copy this link:', shareUrl);
            });
        }

        function loadPreset() {
            const select = document.getElementById('presetSelect');
            const value = select.value;
            
            if (!value) return;
            
            // Check if it's a built-in preset
            if (PRESETS[value]) {
                if (confirm('‚ö†Ô∏è Load this preset?\n\nThis will overwrite your current parameters.')) {
                    setAllParameters(PRESETS[value]);
                    updateCharts();
                    updateURLState();
                }
                select.value = ""; // Reset selection
                return;
            }
            
            // Otherwise it's a saved set
            const savedSets = JSON.parse(localStorage.getItem('simLoyaltySavedSets') || '{}');
            if (savedSets[value]) {
                if (confirm(`‚ö†Ô∏è Load "${value}"?\n\nThis will overwrite your current parameters.`)) {
                    setAllParameters(savedSets[value].params);
                    updateCharts();
                    updateURLState();
                }
                select.value = ""; // Reset selection
            }
        }

        function saveNamedSet() {
            const name = document.getElementById('saveSetName').value.trim();
            if (!name) {
                alert('‚ö†Ô∏è Please enter a name for this parameter set.');
                return;
            }
            
            const savedSets = JSON.parse(localStorage.getItem('simLoyaltySavedSets') || '{}');
            savedSets[name] = {
                params: getAllParameters(),
                timestamp: new Date().toISOString()
            };
            
            localStorage.setItem('simLoyaltySavedSets', JSON.stringify(savedSets));
            document.getElementById('saveSetName').value = '';
            updateSavedSetsList();
            alert(`‚úÖ "${name}" saved successfully!`);
        }

        function updateSavedSetsList() {
            const savedSets = JSON.parse(localStorage.getItem('simLoyaltySavedSets') || '{}');
            const group = document.getElementById('savedSetsGroup');
            group.innerHTML = '';
            
            const names = Object.keys(savedSets).sort();
            if (names.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = '(no saved sets)';
                option.disabled = true;
                group.appendChild(option);
            } else {
                names.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    group.appendChild(option);
                });
            }
        }

        function manageSavedSets() {
            const savedSets = JSON.parse(localStorage.getItem('simLoyaltySavedSets') || '{}');
            const names = Object.keys(savedSets);
            
            if (names.length === 0) {
                alert('‚ÑπÔ∏è No saved sets to manage.');
                return;
            }
            
            const list = names.map((name, i) => `${i + 1}. ${name}`).join('\n');
            const action = prompt(`Your saved sets:\n${list}\n\n‚Ä¢ Enter a set name to DELETE it\n‚Ä¢ Type "CLEAR ALL" to delete all sets\n‚Ä¢ Cancel to go back`);
            
            if (!action) {
                return; // User cancelled
            }
            
            // Check if user wants to clear all
            if (action.toUpperCase() === 'CLEAR ALL') {
                if (confirm(`‚ö†Ô∏è Delete ALL ${names.length} saved sets?\n\nThis cannot be undone!`)) {
                    localStorage.removeItem('simLoyaltySavedSets');
                    updateSavedSetsList();
                    alert(`‚úÖ All saved sets deleted.`);
                }
                return;
            }
            
            // Otherwise try to delete individual set
            if (savedSets[action]) {
                if (confirm(`‚ö†Ô∏è Delete "${action}"?\n\nThis cannot be undone!`)) {
                    delete savedSets[action];
                    localStorage.setItem('simLoyaltySavedSets', JSON.stringify(savedSets));
                    updateSavedSetsList();
                    alert(`‚úÖ "${action}" deleted.`);
                }
            } else {
                alert('‚ö†Ô∏è Set not found.');
            }
        }

        function exportToCSV() {
            // Get current parameters
            const cohortSize = parseFloat(document.getElementById('cohortSize').value);
            const timePeriods = parseInt(document.getElementById('timePeriods').value);
            const shortTermPercent = parseFloat(document.getElementById('shortTermPercent').value) / 100;
            const shortTermChurn = parseFloat(document.getElementById('shortTermChurnRate').value) / 100;
            const mediumTermPercent = parseFloat(document.getElementById('mediumTermPercent').value) / 100;
            const mediumTermChurn = parseFloat(document.getElementById('mediumTermChurnRate').value) / 100;
            const longTermPercent = parseFloat(document.getElementById('longTermPercent').value) / 100;
            const longTermChurn = parseFloat(document.getElementById('longTermChurnRate').value) / 100;

            const T = cohortSize * shortTermPercent;
            const M = cohortSize * mediumTermPercent;
            const L = cohortSize * longTermPercent;

            // Build CSV header - include Actual Data column if we have it
            let csv = 'Month,Short-term Users,Medium-term Users,Long-term Users,Total Retention,Total Customer Base';
            if (actualRetentionData && actualRetentionData.length > 0) {
                csv += ',Actual Data (Fitted)\n';
            } else {
                csv += '\n';
            }
            
            for (let t = 0; t <= timePeriods; t++) {
                const shortTermRem = T * Math.pow(1 - shortTermChurn, t);
                const transRem = M * Math.pow(1 - mediumTermChurn, t);
                const longTermRem = L * Math.pow(1 - longTermChurn, t);
                const totalRetention = shortTermRem + transRem + longTermRem;
                
                // Calculate total customer base (all cohorts)
                let totalBase = 0;
                for (let k = 0; k <= t; k++) {
                    const age = t - k;
                    totalBase += (T * Math.pow(1 - shortTermChurn, age)) + 
                                 (M * Math.pow(1 - mediumTermChurn, age)) + 
                                 (L * Math.pow(1 - longTermChurn, age));
                }
                
                csv += `${t},${Math.round(shortTermRem)},${Math.round(transRem)},${Math.round(longTermRem)},${Math.round(totalRetention)},${Math.round(totalBase)}`;
                
                // Add actual data point if available for this month
                if (actualRetentionData && t < actualRetentionData.length) {
                    const actualUsers = Math.round(actualRetentionData[t] * cohortSize);
                    csv += `,${actualUsers}`;
                }
                csv += '\n';
            }

            // Download
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'sim-loyalty-data.csv';
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }

        // Load parameters from URL on page load
        function loadFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('cohortSize')) {
                const params = {
                    cohortSize: urlParams.get('cohortSize'),
                    timePeriods: urlParams.get('timePeriods'),
                    shortTermPercent: urlParams.get('shortTermPercent'),
                    shortTermChurnRate: urlParams.get('shortTermChurnRate'),
                    mediumTermPercent: urlParams.get('mediumTermPercent'),
                    mediumTermChurnRate: urlParams.get('mediumTermChurnRate'),
                    longTermPercent: urlParams.get('longTermPercent'),
                    longTermChurnRate: urlParams.get('longTermChurnRate')
                };
                setAllParameters(params);
            }
        }

        // Init
        loadFromURL();
        updateSavedSetsList();
        updateCharts();
    </script>
</body>
</html>
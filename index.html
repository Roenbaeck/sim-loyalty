<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sim Loyalty - Customer Retention & Growth Simulator</title>
    <meta name="description" content="Interactive customer retention and growth simulator using a three-segment model. Model churn, predict growth, and fit to real data. Free tool for SaaS, e-commerce, and mobile apps.">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://roenbaeck.github.io/sim-loyalty/">
    <meta property="og:title" content="Sim Loyalty - Customer Retention & Growth Simulator">
    <meta property="og:description" content="Model customer retention and predict growth with a three-segment retention model. Fit to real data, export charts, and compare scenarios. Free interactive tool.">
    <meta property="og:image" content="https://roenbaeck.github.io/sim-loyalty/preview.png">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://roenbaeck.github.io/sim-loyalty/">
    <meta property="twitter:title" content="Sim Loyalty - Customer Retention & Growth Simulator">
    <meta property="twitter:description" content="Model customer retention and predict growth with a three-segment retention model. Fit to real data, export charts, and compare scenarios.">
    <meta property="twitter:image" content="https://roenbaeck.github.io/sim-loyalty/preview.png">
    
    <!-- Professional Font Stack -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --bg-main: #f8fafc;
            --bg-panel: #ffffff;
            --text-heading: #1e293b;
            --text-body: #475569;
            --border-color: #e2e8f0;
            --accent-good: #10b981;
            --accent-warn: #f59e0b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: var(--bg-main);
            color: var(--text-body);
            line-height: 1.5;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* App Header */
        .app-header {
            background: var(--bg-panel);
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .app-logo {
            font-weight: 700;
            font-size: 1.25rem;
            color: var(--text-heading);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .app-logo svg {
            width: 24px;
            height: 24px;
            color: var(--primary);
        }

        .help-button {
            background: none;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-body);
            font-size: 1.125rem;
            font-weight: 600;
            transition: all 0.2s;
        }

        .help-button:hover {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-panel);
            border-radius: 12px;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            padding: 1.5rem 2rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modal-header h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-heading);
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--text-body);
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .modal-close:hover {
            background: var(--bg-main);
        }

        .modal-body {
            padding: 2rem;
        }

        .modal-body h3 {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-heading);
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        .modal-body h3:first-child {
            margin-top: 0;
        }

        .modal-body p {
            margin-bottom: 1rem;
            line-height: 1.6;
        }

        .modal-body ul {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        .modal-body li {
            margin-bottom: 0.5rem;
            line-height: 1.6;
        }

        .modal-body code {
            background: var(--bg-main);
            padding: 0.125rem 0.375rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            color: var(--primary);
        }

        /* Tooltip Styles */
        [data-tooltip] {
            position: relative;
            cursor: help;
        }

        [data-tooltip]:hover::before {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-8px);
            background: rgba(30, 41, 59, 0.95);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-size: 0.8125rem;
            white-space: normal;
            max-width: 250px;
            width: max-content;
            z-index: 100;
            line-height: 1.4;
            font-weight: 400;
        }

        [data-tooltip]:hover::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-2px);
            border: 6px solid transparent;
            border-top-color: rgba(30, 41, 59, 0.95);
            z-index: 100;
        }

        /* Main Layout */
        .app-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebar Controls */
        .controls-panel {
            width: 320px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border-color);
            padding: 2rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .panel-title {
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
            color: var(--text-heading);
            margin-bottom: 1.5rem;
        }

        .control-group {
            margin-bottom: 2rem;
        }

        .input-wrapper {
            margin-bottom: 1.25rem;
        }

        .input-wrapper label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-heading);
            margin-bottom: 0.5rem;
        }

        .input-field-container {
            position: relative;
        }

        .input-field-container input {
            width: 100%;
            padding: 0.625rem 0.875rem;
            padding-right: 4.5rem; /* Space for unit and spinner arrows */
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.925rem;
            color: var(--text-heading);
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
            background: var(--bg-main);
        }

        .input-field-container input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            background: #fff;
        }

        .input-field-container input:disabled {
            background: #f1f5f9;
            color: #94a3b8;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .input-wrapper.disabled {
            opacity: 0.5;
        }

        .input-wrapper.disabled label {
            color: #94a3b8;
        }

        .input-unit {
            position: absolute;
            right: 12px; 
            top: 50%;
            transform: translateY(-50%);
            color: #94a3b8;
            font-size: 0.875rem;
            pointer-events: none;
        }

        .update-btn {
            width: 100%;
            padding: 0.75rem;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: auto;
        }

        .update-btn:hover {
            background-color: var(--primary-hover);
        }

        .export-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .export-btn {
            padding: 0.5rem 0.75rem;
            background-color: var(--bg-main);
            color: var(--text-heading);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.8125rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .export-btn:hover {
            background-color: #e2e8f0;
            border-color: var(--primary);
        }

        .preset-select {
            width: 100%;
            padding: 0.625rem 0.875rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.925rem;
            color: var(--text-heading);
            background: var(--bg-main);
            cursor: pointer;
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
        }

        .preset-select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            background: #fff;
        }

        /* Main Visualization Area */
        .visualization-area {
            flex: 1;
            overflow-y: auto;
            padding: 2rem;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 2rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        .chart-card {
            background: var(--bg-panel);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .chart-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .chart-header h2 {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-heading);
        }

        .kpi-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            border-bottom: 1px solid var(--border-color);
        }

        .kpi-item {
            padding: 1.25rem 1.5rem;
            border-right: 1px solid var(--border-color);
        }
        .kpi-item:last-child { border-right: none; }

        .kpi-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
            color: var(--text-body);
            margin-bottom: 0.5rem;
        }

        .kpi-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-heading);
        }
        .kpi-value.highlight { color: var(--primary); }

        .full-width .kpi-grid {
            grid-template-columns: 1fr;
        }

        .chart-body {
            padding: 1.5rem;
            background: #fff;
            height: 400px;
            position: relative;
        }

        /* Responsive adjustments */
        @media (max-width: 1024px) {
            .app-container {
                flex-direction: column;
                overflow-y: auto;
            }
            .controls-panel {
                width: 100%;
                height: auto;
                overflow-y: visible;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 2rem;
            }
            .update-btn { grid-column: 1 / -1; }
            body { height: auto; }
            .visualization-area { overflow-y: visible; }
        }

        /* Curve Fitting Section */
        .fit-section {
            border-top: 2px solid var(--border-color);
            padding-top: 1.5rem;
            margin-top: 1rem;
        }

        .fit-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding: 0.75rem;
            background: var(--bg-main);
            border-radius: 6px;
            margin-bottom: 1rem;
            transition: background 0.2s;
        }

        .fit-toggle:hover {
            background: #e2e8f0;
        }

        .fit-toggle-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-heading);
        }

        .fit-toggle-icon {
            transition: transform 0.2s;
        }

        .fit-toggle-icon.expanded {
            transform: rotate(180deg);
        }

        .fit-content {
            display: none;
        }

        .fit-content.visible {
            display: block;
        }

        .fit-textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            resize: vertical;
            min-height: 80px;
            background: var(--bg-main);
            color: var(--text-heading);
        }

        .fit-textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .fit-btn {
            width: 100%;
            padding: 0.75rem;
            background-color: var(--accent-good);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 0.75rem;
        }

        .fit-btn:hover {
            background-color: #059669;
            transform: translateY(-1px);
        }

        .fit-result {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: #f0fdf4;
            border: 1px solid #86efac;
            border-radius: 6px;
            font-size: 0.875rem;
            color: #166534;
            display: none;
        }

        .fit-result.visible {
            display: block;
        }

        .fit-result.error {
            background: #fef2f2;
            border-color: #fca5a5;
            color: #991b1b;
        }

        .fit-result.excellent {
            background: #f0fdf4;
            border-color: #86efac;
            color: #166534;
        }

        .fit-result.good {
            background: #fefce8;
            border-color: #fde047;
            color: #854d0e;
        }

        .fit-result.poor {
            background: #fef2f2;
            border-color: #fca5a5;
            color: #991b1b;
        }

        .fit-help {
            font-size: 0.75rem;
            color: var(--text-body);
            margin-top: 0.5rem;
            line-height: 1.4;
        }

        @media (max-width: 768px) {
            .grid-container { grid-template-columns: 1fr; }
            .controls-panel { grid-template-columns: 1fr; gap: 0; }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="app-header">
        <div class="app-logo">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>
            Sim Loyalty
        </div>
        <button class="help-button" onclick="toggleHelp()" aria-label="Help">
            <span>?</span>
        </button>
    </header>

    <!-- Help Modal -->
    <div class="modal-overlay" id="helpModal" onclick="closeHelpIfClickOutside(event)">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìñ How to Use Sim Loyalty</h2>
                <button class="modal-close" onclick="toggleHelp()" aria-label="Close">&times;</button>
            </div>
            <div class="modal-body">
                <h3>üéØ What is Sim Loyalty?</h3>
                <p>Sim Loyalty helps you model customer retention and predict long-term growth using a three-segment retention model. Instead of assuming all customers behave the same, we divide them into groups based on how long they stick around.</p>

                <h3>üìä The Three-Segment Model</h3>
                <p>Customers naturally fall into different retention patterns:</p>
                <ul>
                    <li><strong>Short-term</strong>: High churn rate (~90%/month). These are exploratory users who try your product but don't stick around.</li>
                    <li><strong>Medium-term</strong>: Moderate churn rate (~10%/month). Regular users who engage but may eventually leave.</li>
                    <li><strong>Long-term</strong>: Low churn rate (~1%/month). Your most engaged, loyal customers.</li>
                </ul>
                <p>Each segment follows <strong>exponential decay</strong>: <code>remaining(t) = initial √ó (1 - churn)^t</code></p>

                <h3>ü§î Why Model Instead of Using Raw Data?</h3>
                <p>Great question! Here's why modeling adds value:</p>
                <ul>
                    <li><strong>üîÆ Future Prediction:</strong> Your data shows 12 months; the model predicts months 13-36+ using learned patterns</li>
                    <li><strong>üß™ What-If Scenarios:</strong> Test "What if we reduce churn by 2%?" - impossible with historical data alone</li>
                    <li><strong>üìä Multi-Cohort Growth:</strong> Your data = one cohort. Model = total customer base from overlapping monthly cohorts</li>
                    <li><strong>üéØ Steady-State Planning:</strong> Calculate asymptote (ceiling) - where you'll level off at current acquisition rates</li>
                    <li><strong>üí° Actionable Insights:</strong> "30% short-term, 50% medium-term, 20% loyal" drives strategy better than a list of numbers</li>
                    <li><strong>üìâ Noise Filtering:</strong> Model reveals underlying trend, smoothing random variation and one-time events</li>
                    <li><strong>‚öñÔ∏è Comparison:</strong> Compare products/cohorts by segment parameters, not just curves</li>
                </ul>
                <p><strong>Bottom line:</strong> Actual data = rearview mirror. Model = windshield. You need both to drive forward!</p>

                <h3>üöÄ Getting Started</h3>
                <p><strong>Quick Start:</strong> Select a preset from <strong>Presets & Saved Sets</strong> dropdown (SaaS, E-commerce, Mobile App, or Enterprise B2B) to see example parameters.</p>
                <p><strong>Manual Setup:</strong></p>
                <ul>
                    <li><strong>Step 1:</strong> Set your <strong>Monthly Customer Acquisition</strong></li>
                    <li><strong>Step 2:</strong> Define your <strong>Retention Segments</strong> (must sum to 100%)</li>
                    <li><strong>Step 3:</strong> Click <strong>Run Simulation</strong> to see results</li>
                </ul>
                <p><strong>üí° Tip:</strong> Save your parameters with a custom name to quickly switch between scenarios!</p>

                <h3>üéØ Using Real Data (Advanced)</h3>
                <p>If you have actual retention data from your analytics:</p>
                <ul>
                    <li>Click <strong>"üéØ Fit Model to Data"</strong></li>
                    <li>Paste retention percentages (one per month, starting at 100%)</li>
                    <li>Click <strong>Fit Parameters</strong> to calculate optimal segment parameters</li>
                    <li>Your actual data appears as <strong>light blue dots</strong> on the retention chart</li>
                    <li>The blue line shows the fitted model - compare visually!</li>
                </ul>
                <p><strong>üî¨ Advanced Multi-Method Optimization:</strong> The curve fitting uses 4 different optimization algorithms simultaneously (Grid Search, Differential Evolution, Random Restart, and Simulated Annealing) and automatically selects the best result. This ensures robust fitting across diverse retention patterns, from simple exponential decay to complex multi-segment behaviors.</p>

                <h3>üíæ Save & Share Your Work</h3>
                <ul>
                    <li><strong>Save Named Sets:</strong> Enter a name and click üíæ Save to store parameters (including fitted data)</li>
                    <li><strong>Load Presets:</strong> Use built-in examples (SaaS, E-commerce, Mobile App, Enterprise)</li>
                    <li><strong>Export Charts:</strong> Download retention or growth charts as PNG images</li>
                    <li><strong>Export Data:</strong> Download simulation results as CSV for Excel/Sheets</li>
                    <li><strong>Share Links:</strong> Click üîó Copy Link to share your exact parameters with colleagues</li>
                </ul>

                <h3>üìà Understanding the Charts</h3>
                <p><strong>Single Cohort Retention:</strong> Shows how one group of customers decays over time. Light blue dots (if present) show your actual data vs. the fitted model (blue line).</p>
                <p><strong>Multi-Cohort Growth:</strong> Shows your total customer base when adding new cohorts monthly. The dashed line shows the theoretical ceiling (asymptote).</p>

                <h3>üìä Key Metrics Explained</h3>
                <ul>
                    <li><strong>Cohort Half-Life (Median):</strong> Time when 50% of customers have churned</li>
                    <li><strong>Mean Lifetime:</strong> Average customer lifespan (weighted by segment size)</li>
                    <li><strong>Growth Asymptote:</strong> Steady-state customer base where new acquisition = total churn</li>
                    <li><strong>Avg Error (MAPE):</strong> Average error between model and data (&lt;5% = excellent, 5-10% = good, &gt;10% = review fit visually)</li>
                    <li><strong>R¬≤:</strong> Variance explained (can be misleading for visual fit - use Avg Error instead)</li>
                </ul>

                <h3>‚ö†Ô∏è Model Limitations</h3>
                <p>The three-segment exponential model works best for:</p>
                <ul>
                    <li>‚úÖ Steady churn patterns (SaaS, subscriptions, consumer apps)</li>
                    <li>‚úÖ Multiple distinct customer behavior groups</li>
                    <li>‚úÖ Exponential decay within segments (including 0% churn = plateau)</li>
                    <li>‚úÖ Gradual reactivation (captured as lower effective churn rates)</li>
                </ul>
                <p>It may struggle with:</p>
                <ul>
                    <li>‚ùå S-curves (slow start, then rapid churn)</li>
                    <li>‚ùå U-curves/Smiley patterns (retention improving over time)</li>
                    <li>‚ùå Sudden step changes in retention</li>
                    <li>‚ùå Massive reactivation campaigns (churned users returning en masse)</li>
                    <li>‚ùå Network effects (retention improving as product matures)</li>
                    <li>‚ùå Seasonal or time-varying churn rates</li>
                </ul>
                <p><strong>Check the Avg Error %</strong> when fitting. If &gt;10%, visually inspect the light blue dots - look for systematic patterns that the model misses.</p>

                <h3>ÔøΩ Note on Acquisition Growth</h3>
                <p>This model assumes <strong>fixed monthly acquisition</strong> to isolate retention dynamics and calculate steady-state (asymptote). This assumption is realistic for:</p>
                <ul>
                    <li>Mature businesses in stable markets</li>
                    <li>Companies with consistent marketing spend</li>
                    <li>Market-share limited acquisition (e.g., B2B, niches)</li>
                </ul>
                <p>Fixed acquisition lets you answer key strategic questions:</p>
                <ul>
                    <li>"At 1,000 customers/month, what's our ceiling?"</li>
                    <li>"How much does improving retention lift our steady-state?"</li>
                </ul>
                <p><strong>For high-growth scenarios</strong> (e.g., 1,000 ‚Üí 1,500 ‚Üí 2,000/month), run multiple scenarios at different acquisition levels and interpolate externally. Mixing acquisition growth with retention modeling makes it harder to isolate what drives results.</p>

                <h3>üí° Tips</h3>
                <ul>
                    <li>Try the built-in presets to learn the model quickly</li>
                    <li>Save multiple scenarios to compare different strategies</li>
                    <li>Use real data fitting for accuracy - the light blue dots show fit quality</li>
                    <li>Watch the Avg Error % - if it's high, inspect the dots visually</li>
                    <li>Export charts for presentations and reports</li>
                    <li>Share links with teammates to discuss assumptions</li>
                </ul>

                <h3>üß™ Stress Test Examples</h3>
                <p>Try fitting these patterns to see model performance:</p>
                
                <p><strong>S-Curve (Poor Fit Expected):</strong><br>
                <code>100, 95, 90, 85, 75, 60, 40, 25, 18, 15, 13, 12</code><br>
                <em>Slow initial churn, then rapid - model struggles with this pattern</em></p>
                
                <p><strong>Smiley/U-Curve (Poor Fit Expected):</strong><br>
                <code>100, 70, 50, 40, 35, 38, 42, 47, 52, 56, 60, 63</code><br>
                <em>Retention improves over time (reactivation/network effects) - exponential decay can't capture this</em></p>
                
                <p><strong>Typical SaaS (Excellent Fit):</strong><br>
                <code>100, 82, 73, 65, 58, 52, 47, 43, 39, 36, 33, 31</code><br>
                <em>Classic exponential decay - model excels here</em></p>
                
                <p><strong>Plateau/Sticky Users (Excellent Fit):</strong><br>
                <code>100, 80, 70, 65, 63, 62, 61, 60, 60, 60, 60, 60</code><br>
                <em>Model handles this well with long-term segment at 0% churn</em></p>
            </div>
        </div>
    </div>

    <!-- Main App -->
    <div class="app-container">
        <!-- Left Sidebar Controls -->
        <aside class="controls-panel">
            <div class="control-group">
                <h3 class="panel-title">Cohort Dynamics</h3>
                <div class="fit-help" style="margin-bottom: 1rem;">
                    Model your customer acquisition and retention over time.
                </div>
                
                <div class="input-wrapper">
                    <label for="cohortSize" data-tooltip="Number of new customers acquired each month">Monthly Customer Acquisition</label>
                    <div class="input-field-container">
                        <input type="number" id="cohortSize" value="1000" min="1" step="1">
                        <span class="input-unit">users</span>
                    </div>
                </div>

                <div class="input-wrapper">
                    <label for="timePeriods" data-tooltip="How many months to simulate into the future">Simulation Duration</label>
                    <div class="input-field-container">
                        <input type="number" id="timePeriods" value="36" min="1" step="1">
                        <span class="input-unit">months</span>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h3 class="panel-title">Retention Segments</h3>
                <div class="fit-help" style="margin-bottom: 1rem;">
                    Divide your cohort into groups based on customer longevity and retention behavior.
                </div>
                
                <div class="input-wrapper">
                    <label for="shortTermPercent" data-tooltip="Percentage of new customers who are exploratory users with high churn">Short-term Segment Size</label>
                    <div class="input-field-container">
                        <input type="number" id="shortTermPercent" value="20" min="0" max="100" step="0.1">
                        <span class="input-unit">%</span>
                    </div>
                </div>

                <div class="input-wrapper">
                    <label for="shortTermChurnRate" data-tooltip="Monthly churn rate for short-term customers (typically 70-95%)">Short-term Churn Rate</label>
                    <div class="input-field-container">
                        <input type="number" id="shortTermChurnRate" value="90" min="0" max="100" step="0.1">
                        <span class="input-unit">% / mo</span>
                    </div>
                </div>

                <div class="input-wrapper">
                    <label for="mediumTermPercent" data-tooltip="Percentage of new customers who are regular users with moderate retention">Medium-term Segment Size</label>
                    <div class="input-field-container">
                        <input type="number" id="mediumTermPercent" value="60" min="0" max="100" step="0.1">
                        <span class="input-unit">%</span>
                    </div>
                </div>

                <div class="input-wrapper">
                    <label for="mediumTermChurnRate" data-tooltip="Monthly churn rate for medium-term customers (typically 5-15%)">Medium-term Churn Rate</label>
                    <div class="input-field-container">
                        <input type="number" id="mediumTermChurnRate" value="10" min="0" max="100" step="0.1">
                        <span class="input-unit">% / mo</span>
                    </div>
                </div>

                <div class="input-wrapper">
                    <label for="longTermPercent" data-tooltip="Percentage of new customers who become highly engaged with low churn">Long-term Segment Size</label>
                    <div class="input-field-container">
                        <input type="number" id="longTermPercent" value="20" min="0" max="100" step="0.1">
                        <span class="input-unit">%</span>
                    </div>
                </div>

                <div class="input-wrapper">
                    <label for="longTermChurnRate" data-tooltip="Monthly churn rate for long-term loyal customers (typically 0.5-3%)">Long-term Churn Rate</label>
                    <div class="input-field-container">
                        <input type="number" id="longTermChurnRate" value="1" min="0" max="100" step="0.1">
                        <span class="input-unit">% / mo</span>
                    </div>
                </div>

                <!-- Curve Fitting Section -->
                <div class="fit-section">
                    <div class="fit-toggle" onclick="toggleFitPanel()">
                        <span class="fit-toggle-title">üéØ Fit Model to Data</span>
                        <span class="fit-toggle-icon" id="fitToggleIcon">‚ñº</span>
                    </div>
                    <div class="fit-content" id="fitContent">
                        <label style="display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.5rem;">
                            Retention Data (% remaining)
                        </label>
                        <textarea 
                            id="retentionData" 
                            class="fit-textarea" 
                            placeholder="Enter retention percentages, one per line or comma-separated:&#10;100&#10;82&#10;73&#10;65&#10;58&#10;52&#10;..."></textarea>
                        <div class="fit-help">
                            Paste your cohort retention data starting at 100%. Each value represents the percentage of customers remaining after each period. Your actual data will appear as light blue points on the retention chart.
                        </div>
                        <button class="fit-btn" onclick="fitModelToData()">Fit Parameters</button>
                        <div class="fit-result" id="fitResult"></div>
                    </div>
                </div>
            </div>

            <button class="update-btn" onclick="updateCharts()">Run Simulation</button>

            <!-- Presets & Saved Sets Section -->
            <div class="control-group" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                <h3 class="panel-title">Presets & Saved Sets</h3>
                
                <div class="input-wrapper">
                    <label for="presetSelect">Load Example or Saved Set</label>
                    <select id="presetSelect" onchange="loadPreset()" class="preset-select">
                        <option value="">-- Select --</option>
                        <optgroup label="Example Presets">
                            <option value="saas">SaaS Startup</option>
                            <option value="ecommerce">E-commerce</option>
                            <option value="mobile">Mobile App</option>
                            <option value="enterprise">Enterprise B2B</option>
                        </optgroup>
                        <optgroup label="Your Saved Sets" id="savedSetsGroup">
                        </optgroup>
                    </select>
                </div>

                <div class="input-wrapper">
                    <label for="saveSetName">Save Current Parameters As</label>
                    <div style="display: flex; gap: 0.5rem;">
                        <input type="text" id="saveSetName" placeholder="My Scenario" class="input-field-container" style="flex: 1; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 6px;">
                        <button class="export-btn" onclick="saveNamedSet()" style="width: auto; padding: 0.5rem 1rem;">üíæ</button>
                    </div>
                </div>

                <button class="export-btn" onclick="manageSavedSets()" style="width: 100%; margin-top: 0.5rem;">
                    üóëÔ∏è Manage Saved Sets
                </button>
            </div>

            <!-- Export Section -->
            <div class="control-group" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                <h3 class="panel-title">Export & Share</h3>
                
                <div class="export-buttons">
                    <button class="export-btn" onclick="downloadRetentionChart()" title="Download retention chart as PNG">
                        Retention PNG
                    </button>
                    <button class="export-btn" onclick="downloadGrowthChart()" title="Download growth chart as PNG">
                        Growth PNG
                    </button>
                    <button class="export-btn" onclick="exportToCSV()" title="Export simulation data to CSV">
                        Export CSV
                    </button>
                    <button class="export-btn" onclick="copyShareableLink()" title="Copy shareable link with current parameters">
                        Copy Link
                    </button>
                </div>
            </div>
        </aside>

        <!-- Main Visualization Area -->
        <main class="visualization-area">
            <div class="grid-container">
                <!-- Chart 1: Retention -->
                <div class="chart-card">
                    <div class="chart-header">
                        <h2>Single Cohort Retention</h2>
                    </div>
                    <div class="kpi-grid">
                        <div class="kpi-item">
                            <div class="kpi-label" data-tooltip="Time when 50% of the cohort has churned (median customer lifetime)">Cohort Half-Life</div>
                            <div class="kpi-value" id="medianDisplay">--</div>
                        </div>
                        <div class="kpi-item">
                            <div class="kpi-label" data-tooltip="Average customer lifespan, weighted by segment sizes">Mean Lifetime</div>
                            <div class="kpi-value" id="meanDisplay">--</div>
                        </div>
                    </div>
                    <div class="chart-body">
                        <canvas id="retentionChart"></canvas>
                    </div>
                </div>

                <!-- Chart 2: Growth -->
                <div class="chart-card full-width">
                    <div class="chart-header">
                        <h2>Total Customer Base Growth</h2>
                    </div>
                    <div class="kpi-grid">
                        <div class="kpi-item" style="border-right: none;">
                            <div class="kpi-label" data-tooltip="Steady-state customer base where new acquisitions equal total churn">Theoretical Ceiling (Asymptote)</div>
                            <div class="kpi-value highlight" id="asymptoteDisplay">--</div>
                            <div style="font-size: 0.8rem; color: var(--text-body); margin-top: 4px;" id="asymptoteFormula"></div>
                        </div>
                    </div>
                    <div class="chart-body">
                        <canvas id="growthChart"></canvas>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // --- Global State ---
        let actualRetentionData = null; // Store actual data points from curve fitting

        // --- Chart Global Configuration for a more professional look ---
        Chart.defaults.font.family = "'Inter', -apple-system, BlinkMacSystemFont, sans-serif";
        Chart.defaults.color = '#64748b';
        Chart.defaults.scale.grid.color = '#f1f5f9';
        Chart.defaults.plugins.tooltip.backgroundColor = 'rgba(30, 41, 59, 0.9)';
        Chart.defaults.plugins.tooltip.padding = 12;
        Chart.defaults.plugins.tooltip.cornerRadius = 8;

        // --- Segment UI Management ---
        function updateChurnFieldStates() {
            const segments = [
                { percentId: 'shortTermPercent', churnId: 'shortTermChurnRate' },
                { percentId: 'mediumTermPercent', churnId: 'mediumTermChurnRate' },
                { percentId: 'longTermPercent', churnId: 'longTermChurnRate' }
            ];

            segments.forEach(segment => {
                const percentValue = parseFloat(document.getElementById(segment.percentId).value);
                const churnField = document.getElementById(segment.churnId);
                const churnWrapper = churnField.closest('.input-wrapper');
                
                if (percentValue === 0) {
                    churnField.disabled = true;
                    churnWrapper.classList.add('disabled');
                } else {
                    churnField.disabled = false;
                    churnWrapper.classList.remove('disabled');
                }
            });
        }

        // Add event listeners to segment size fields
        document.addEventListener('DOMContentLoaded', function() {
            ['shortTermPercent', 'mediumTermPercent', 'longTermPercent'].forEach(id => {
                document.getElementById(id).addEventListener('input', updateChurnFieldStates);
            });
            // Initialize on load
            updateChurnFieldStates();
        });

        // --- Curve Fitting Functions ---
        function toggleFitPanel() {
            const content = document.getElementById('fitContent');
            const icon = document.getElementById('fitToggleIcon');
            content.classList.toggle('visible');
            icon.classList.toggle('expanded');
        }

        function parseRetentionData(input) {
            // Parse input - supports comma-separated or line-separated values
            const values = input
                .split(/[\n,]+/)
                .map(v => v.trim())
                .filter(v => v.length > 0)
                .map(v => parseFloat(v));
            
            // Validate
            if (values.length < 4) {
                throw new Error('Need at least 4 data points for fitting');
            }
            if (values.some(v => isNaN(v) || v < 0 || v > 100)) {
                throw new Error('All values must be valid percentages (0-100)');
            }
            if (values[0] !== 100) {
                throw new Error('First value should be 100% (starting cohort)');
            }
            
            // Convert to decimals
            return values.map(v => v / 100);
        }

        function retentionModel(t, params) {
            const [shortTermPct, mediumTermPct, longTermPct, shortTermChurn, mediumTermChurn, longTermChurn] = params;
            return shortTermPct * Math.pow(1 - shortTermChurn, t) + 
                   mediumTermPct * Math.pow(1 - mediumTermChurn, t) + 
                   longTermPct * Math.pow(1 - longTermChurn, t);
        }

        function calculateError(params, data) {
            // Sum of squared errors
            let error = 0;
            for (let t = 0; t < data.length; t++) {
                const predicted = retentionModel(t, params);
                const actual = data[t];
                error += Math.pow(predicted - actual, 2);
            }
            return error;
        }

        function fitModelToData() {
            const resultDiv = document.getElementById('fitResult');
            const input = document.getElementById('retentionData').value;
            
            try {
                // Parse data
                const data = parseRetentionData(input);
                
                // Store actual data for visualization
                actualRetentionData = data;
                
                // Show processing
                resultDiv.className = 'fit-result visible';
                resultDiv.innerHTML = 'üîÑ Fitting model... This may take a few seconds.';
                
                // Run optimization in a timeout to allow UI update
                setTimeout(() => {
                    try {
                        const result = optimizeParameters(data);
                        
                        // Update input fields with fitted parameters
                        document.getElementById('shortTermPercent').value = (result.shortTermPercent * 100).toFixed(1);
                        document.getElementById('shortTermChurnRate').value = (result.shortTermChurn * 100).toFixed(1);
                        document.getElementById('mediumTermPercent').value = (result.mediumTermPercent * 100).toFixed(1);
                        document.getElementById('mediumTermChurnRate').value = (result.mediumTermChurn * 100).toFixed(1);
                        document.getElementById('longTermPercent').value = (result.longTermPercent * 100).toFixed(1);
                        document.getElementById('longTermChurnRate').value = (result.longTermChurn * 100).toFixed(1);
                        
                        // Update churn field states (disable if segment is 0%)
                        updateChurnFieldStates();
                        
                        // Assess fit quality using MAPE (more intuitive than R¬≤)
                        const mape = result.mape;
                        const r2 = result.rSquared;
                        let qualityIcon = '‚úÖ';
                        let qualityText = 'Excellent fit';
                        let qualityClass = 'excellent';
                        let warning = '';
                        
                        if (mape > 10) {
                            qualityIcon = '‚ö†Ô∏è';
                            qualityText = 'Poor fit';
                            qualityClass = 'poor';
                            warning = '<br><br><strong>‚ö†Ô∏è Visual Fit Issue Detected:</strong><br>The model shows significant deviations from your data (avg error: ' + mape.toFixed(1) + '%). Possible reasons:<br>‚Ä¢ Non-exponential decay pattern (S-curves, sudden changes)<br>‚Ä¢ Time-varying churn (seasonal effects)<br>‚Ä¢ Customer reactivation patterns<br><br><strong>Check the light blue dots:</strong> Look for systematic patterns in the errors.';
                        } else if (mape > 5) {
                            qualityIcon = '‚ö°';
                            qualityText = 'Good fit';
                            qualityClass = 'good';
                            warning = '<br><br><em>Note: Minor deviations detected (avg error: ' + mape.toFixed(1) + '%). Visually inspect the light blue dots for any patterns.</em>';
                        }
                        
                        // Show success message with quality assessment
                        resultDiv.className = 'fit-result visible ' + qualityClass;
                        resultDiv.innerHTML = `
                            <strong>${qualityIcon} Model fitted successfully!</strong><br>
                            Short-Term: ${(result.shortTermPercent * 100).toFixed(1)}% (${(result.shortTermChurn * 100).toFixed(1)}% churn)<br>
                            Medium-Term: ${(result.mediumTermPercent * 100).toFixed(1)}% (${(result.mediumTermChurn * 100).toFixed(1)}% churn)<br>
                            Long-Term: ${(result.longTermPercent * 100).toFixed(1)}% (${(result.longTermChurn * 100).toFixed(1)}% churn)<br>
                            <br><strong>Avg Error: ${mape.toFixed(1)}%</strong> (${qualityText})<br>
                            <small>R¬≤ = ${r2.toFixed(4)}</small>${warning}
                        `;
                        
                        // Update charts
                        updateCharts();
                    } catch (error) {
                        resultDiv.className = 'fit-result visible error';
                        resultDiv.innerHTML = '‚ùå Optimization failed: ' + error.message;
                    }
                }, 100);
                
            } catch (error) {
                resultDiv.className = 'fit-result visible error';
                resultDiv.innerHTML = '‚ùå ' + error.message;
            }
        }

        function optimizeParameters(data) {
            // Multi-method optimization: Try multiple algorithms and pick the best result
            const methods = [];
            
            // Method 1: Improved Grid Search + Nelder-Mead
            methods.push(optimizeGridSearch(data));
            
            // Method 2: Differential Evolution
            methods.push(optimizeDifferentialEvolution(data));
            
            // Method 3: Random Restart with Nelder-Mead
            methods.push(optimizeRandomRestart(data));
            
            // Method 4: Simulated Annealing
            methods.push(optimizeSimulatedAnnealing(data));
            
            // Select the best result based on error
            let bestResult = methods[0];
            let bestError = calculateError(
                [bestResult.shortTermPercent, bestResult.mediumTermPercent, bestResult.longTermPercent,
                 bestResult.shortTermChurn, bestResult.mediumTermChurn, bestResult.longTermChurn],
                data
            );
            
            for (let i = 1; i < methods.length; i++) {
                const error = calculateError(
                    [methods[i].shortTermPercent, methods[i].mediumTermPercent, methods[i].longTermPercent,
                     methods[i].shortTermChurn, methods[i].mediumTermChurn, methods[i].longTermChurn],
                    data
                );
                if (error < bestError) {
                    bestError = error;
                    bestResult = methods[i];
                }
            }
            
            return bestResult;
        }

        function optimizeGridSearch(data) {
            // Original grid search + Nelder-Mead method (improved)
            const firstDrop = 1 - data[1];
            
            let bestParams = [
                Math.min(0.4, firstDrop * 0.8),
                0.4,
                0.2,
                0.95,
                0.10,
                0.01
            ];
            
            const segmentSum = bestParams[0] + bestParams[1] + bestParams[2];
            bestParams[0] /= segmentSum;
            bestParams[1] /= segmentSum;
            bestParams[2] /= segmentSum;
            
            let bestError = calculateError(bestParams, data);
            
            // Finer grid search
            for (let tp = 0; tp <= 0.6; tp += 0.15) {
                for (let mp = 0.2; mp <= 0.7; mp += 0.15) {
                    const lp = 1 - tp - mp;
                    if (lp < 0 || lp > 1) continue;
                    
                    for (let tc = 0.6; tc <= 0.99; tc += 0.1) {
                        for (let mc = 0.03; mc <= 0.30; mc += 0.06) {
                            for (let lc = 0; lc <= 0.06; lc += 0.02) {
                                const params = [tp, mp, lp, tc, mc, lc];
                                const error = calculateError(params, data);
                                if (error < bestError) {
                                    bestError = error;
                                    bestParams = [...params];
                                }
                            }
                        }
                    }
                }
            }
            
            const result = nelderMead(bestParams, data);
            return formatOptimizationResult(result.params, data);
        }

        function optimizeDifferentialEvolution(data) {
            // Differential Evolution: Global optimization algorithm
            const popSize = 30;
            const maxGen = 100;
            const F = 0.8;  // Differential weight
            const CR = 0.9; // Crossover probability
            const bounds = [
                [0, 1], [0, 1], [0, 1],  // segment percentages
                [0.5, 0.99], [0.01, 0.5], [0, 0.1]  // churn rates
            ];
            
            // Initialize population
            let population = [];
            for (let i = 0; i < popSize; i++) {
                const individual = [
                    Math.random(), Math.random(), Math.random(),
                    0.5 + Math.random() * 0.49,
                    0.01 + Math.random() * 0.49,
                    Math.random() * 0.1
                ];
                // Normalize segments
                const sum = individual[0] + individual[1] + individual[2];
                individual[0] /= sum;
                individual[1] /= sum;
                individual[2] /= sum;
                population.push(individual);
            }
            
            // Evolution
            for (let gen = 0; gen < maxGen; gen++) {
                for (let i = 0; i < popSize; i++) {
                    // Select three random individuals (different from i)
                    const indices = [];
                    while (indices.length < 3) {
                        const idx = Math.floor(Math.random() * popSize);
                        if (idx !== i && !indices.includes(idx)) {
                            indices.push(idx);
                        }
                    }
                    
                    // Mutation: v = a + F * (b - c)
                    const trial = [];
                    for (let j = 0; j < 6; j++) {
                        if (Math.random() < CR || j === Math.floor(Math.random() * 6)) {
                            let value = population[indices[0]][j] + F * (population[indices[1]][j] - population[indices[2]][j]);
                            // Clamp to bounds
                            value = Math.max(bounds[j][0], Math.min(bounds[j][1], value));
                            trial.push(value);
                        } else {
                            trial.push(population[i][j]);
                        }
                    }
                    
                    // Normalize segments
                    const sum = trial[0] + trial[1] + trial[2];
                    trial[0] /= sum;
                    trial[1] /= sum;
                    trial[2] /= sum;
                    
                    // Selection: Keep if better
                    if (calculateError(trial, data) < calculateError(population[i], data)) {
                        population[i] = trial;
                    }
                }
            }
            
            // Find best individual
            let bestParams = population[0];
            let bestError = calculateError(bestParams, data);
            for (let i = 1; i < popSize; i++) {
                const error = calculateError(population[i], data);
                if (error < bestError) {
                    bestError = error;
                    bestParams = population[i];
                }
            }
            
            // Refine with Nelder-Mead
            const result = nelderMead(bestParams, data, 100);
            return formatOptimizationResult(result.params, data);
        }

        function optimizeRandomRestart(data) {
            // Random restart: Try multiple random starting points with Nelder-Mead
            const numRestarts = 15;
            let bestResult = null;
            let bestError = Infinity;
            
            for (let i = 0; i < numRestarts; i++) {
                // Random initial parameters
                const tp = Math.random() * 0.6;
                const mp = Math.random() * (1 - tp);
                const lp = 1 - tp - mp;
                
                const initialParams = [
                    tp, mp, lp,
                    0.5 + Math.random() * 0.49,  // shortTermChurn: 0.5-0.99
                    0.01 + Math.random() * 0.49,  // mediumTermChurn: 0.01-0.5
                    Math.random() * 0.1           // longTermChurn: 0-0.1
                ];
                
                const result = nelderMead(initialParams, data, 150);
                const error = result.error;
                
                if (error < bestError) {
                    bestError = error;
                    bestResult = result.params;
                }
            }
            
            return formatOptimizationResult(bestResult, data);
        }

        function optimizeSimulatedAnnealing(data) {
            // Simulated Annealing: Probabilistic optimization that can escape local minima
            const maxIterations = 2000;
            let temperature = 1.0;
            const coolingRate = 0.995;
            const minTemperature = 0.001;
            
            // Random initial state
            let tp = Math.random() * 0.6;
            let mp = Math.random() * (1 - tp);
            let lp = 1 - tp - mp;
            
            let currentState = [
                tp, mp, lp,
                0.5 + Math.random() * 0.49,  // shortTermChurn
                0.01 + Math.random() * 0.49,  // mediumTermChurn
                Math.random() * 0.1           // longTermChurn
            ];
            
            let currentEnergy = calculateError(currentState, data);
            let bestState = [...currentState];
            let bestEnergy = currentEnergy;
            
            for (let iter = 0; iter < maxIterations && temperature > minTemperature; iter++) {
                // Generate neighbor by perturbing current state
                const neighbor = currentState.map((val, idx) => {
                    const perturbation = (Math.random() - 0.5) * 0.1 * temperature;
                    let newVal = val + perturbation;
                    
                    // Apply bounds
                    if (idx < 3) {
                        newVal = Math.max(0, Math.min(1, newVal));
                    } else if (idx === 3) {
                        newVal = Math.max(0.5, Math.min(0.99, newVal));
                    } else if (idx === 4) {
                        newVal = Math.max(0.01, Math.min(0.5, newVal));
                    } else {
                        newVal = Math.max(0, Math.min(0.1, newVal));
                    }
                    
                    return newVal;
                });
                
                // Normalize segments
                const sum = neighbor[0] + neighbor[1] + neighbor[2];
                neighbor[0] /= sum;
                neighbor[1] /= sum;
                neighbor[2] /= sum;
                
                const neighborEnergy = calculateError(neighbor, data);
                const deltaE = neighborEnergy - currentEnergy;
                
                // Accept neighbor if better, or with probability based on temperature
                if (deltaE < 0 || Math.random() < Math.exp(-deltaE / temperature)) {
                    currentState = neighbor;
                    currentEnergy = neighborEnergy;
                    
                    // Update best if improved
                    if (currentEnergy < bestEnergy) {
                        bestState = [...currentState];
                        bestEnergy = currentEnergy;
                    }
                }
                
                // Cool down
                temperature *= coolingRate;
            }
            
            // Final refinement with Nelder-Mead
            const result = nelderMead(bestState, data, 100);
            return formatOptimizationResult(result.params, data);
        }

        function formatOptimizationResult(params, data) {
            // Normalize segments to sum to 100%
            let shortTermPct = Math.max(0, params[0]);
            let mediumTermPct = Math.max(0, params[1]);
            let longTermPct = Math.max(0, params[2]);
            const total = shortTermPct + mediumTermPct + longTermPct;
            
            const normalizedParams = [
                shortTermPct / total,
                mediumTermPct / total,
                longTermPct / total,
                Math.max(0, Math.min(0.99, params[3])),
                Math.max(0.001, Math.min(0.99, params[4])),
                Math.max(0, Math.min(0.99, params[5]))
            ];
            
            // Generate predicted values
            const predicted = data.map((_, i) => {
                const t = i;
                const shortTerm = normalizedParams[0] * Math.pow(1 - normalizedParams[3], t);
                const mediumTerm = normalizedParams[1] * Math.pow(1 - normalizedParams[4], t);
                const longTerm = normalizedParams[2] * Math.pow(1 - normalizedParams[5], t);
                return (shortTerm + mediumTerm + longTerm);
            });
            
            // Calculate R¬≤
            const n = data.length;
            const meanActual = data.reduce((sum, val) => sum + val, 0) / n;
            let ssRes = 0;
            let ssTot = 0;
            for (let i = 0; i < n; i++) {
                ssRes += Math.pow(data[i] - predicted[i], 2);
                ssTot += Math.pow(data[i] - meanActual, 2);
            }
            const rSquared = (ssTot === 0) ? 1 : (1 - (ssRes / ssTot));
            
            // Calculate MAPE
            let mapeSum = 0;
            let mapeCount = 0;
            for (let i = 0; i < data.length; i++) {
                if (data[i] !== 0) {
                    mapeSum += Math.abs((data[i] - predicted[i]) / data[i]);
                    mapeCount++;
                }
            }
            const mape = (mapeCount > 0) ? (mapeSum / mapeCount) * 100 : 0;
            
            return {
                shortTermPercent: normalizedParams[0],
                mediumTermPercent: normalizedParams[1],
                longTermPercent: normalizedParams[2],
                shortTermChurn: normalizedParams[3],
                mediumTermChurn: normalizedParams[4],
                longTermChurn: normalizedParams[5],
                rSquared: rSquared,
                mape: mape
            };
        }

        function nelderMead(initialParams, data, maxIterations = 200) {
            const alpha = 1.0;  // Reflection
            const gamma = 2.0;  // Expansion
            const rho = 0.5;    // Contraction
            const sigma = 0.5;  // Shrink
            
            // Create initial simplex
            const n = initialParams.length;
            let simplex = [initialParams];
            
            for (let i = 0; i < n; i++) {
                const point = [...initialParams];
                point[i] += 0.05; // Small perturbation
                simplex.push(point);
            }
            
            // Evaluate simplex
            let errors = simplex.map(p => calculateError(p, data));
            
            for (let iter = 0; iter < maxIterations; iter++) {
                // Sort by error
                const indices = errors.map((e, i) => i).sort((a, b) => errors[a] - errors[b]);
                simplex = indices.map(i => simplex[i]);
                errors = indices.map(i => errors[i]);
                
                // Check convergence
                if (errors[n] - errors[0] < 1e-8) break;
                
                // Calculate centroid (excluding worst point)
                const centroid = new Array(n).fill(0);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        centroid[j] += simplex[i][j];
                    }
                }
                for (let j = 0; j < n; j++) {
                    centroid[j] /= n;
                }
                
                // Reflection
                const reflected = centroid.map((c, i) => c + alpha * (c - simplex[n][i]));
                const reflectedError = calculateError(reflected, data);
                
                if (reflectedError < errors[0]) {
                    // Expansion
                    const expanded = centroid.map((c, i) => c + gamma * (reflected[i] - c));
                    const expandedError = calculateError(expanded, data);
                    
                    if (expandedError < reflectedError) {
                        simplex[n] = expanded;
                        errors[n] = expandedError;
                    } else {
                        simplex[n] = reflected;
                        errors[n] = reflectedError;
                    }
                } else if (reflectedError < errors[n - 1]) {
                    simplex[n] = reflected;
                    errors[n] = reflectedError;
                } else {
                    // Contraction
                    const contracted = centroid.map((c, i) => c + rho * (simplex[n][i] - c));
                    const contractedError = calculateError(contracted, data);
                    
                    if (contractedError < errors[n]) {
                        simplex[n] = contracted;
                        errors[n] = contractedError;
                    } else {
                        // Shrink
                        for (let i = 1; i <= n; i++) {
                            simplex[i] = simplex[0].map((s0, j) => s0 + sigma * (simplex[i][j] - s0));
                            errors[i] = calculateError(simplex[i], data);
                        }
                    }
                }
            }
            
            return { params: simplex[0], error: errors[0] };
        }

        const retentionCtx = document.getElementById('retentionChart').getContext('2d');
        const growthCtx = document.getElementById('growthChart').getContext('2d');
        
        const retentionChart = new Chart(retentionCtx, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        align: 'end',
                        labels: { 
                            boxWidth: 12, 
                            usePointStyle: true,
                            filter: function(item) {
                                // Only show legend if we have actual data points
                                return item.text !== 'Model Prediction' || actualRetentionData;
                            }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                // Round to nearest whole number for user counts
                                label += Math.round(context.parsed.y).toLocaleString();
                                return label;
                            }
                        }
                    },
                    annotation: { annotations: {} }
                },
                scales: {
                    x: {
                        title: { display: true, text: 'Months Since Acqusition', font: { weight: 500 } },
                        grid: { display: false }
                    },
                    y: {
                        beginAtZero: true,
                        title: { display: true, text: 'Users Remaining', font: { weight: 500 } }
                    }
                }
            }
        });
        
        const growthChart = new Chart(growthCtx, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                plugins: {
                    legend: {
                        position: 'top',
                        align: 'end',
                        labels: { boxWidth: 12, usePointStyle: true }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                // Round to nearest whole number for user counts
                                label += Math.round(context.parsed.y).toLocaleString();
                                return label;
                            }
                        }
                    },
                    annotation: { annotations: {} }
                },
                scales: {
                    x: {
                        title: { display: true, text: 'Months Passed', font: { weight: 500 } },
                        grid: { display: false }
                    },
                    y: {
                        beginAtZero: true,
                        title: { display: true, text: 'Total Active Customers', font: { weight: 500 } }
                    }
                }
            }
        });

        function updateCharts() {
            // Get input values
            const shortTermPercent = parseFloat(document.getElementById('shortTermPercent').value) / 100;
            const shortTermChurn = parseFloat(document.getElementById('shortTermChurnRate').value) / 100;
            const mediumTermPercent = parseFloat(document.getElementById('mediumTermPercent').value) / 100;
            const mediumTermChurn = parseFloat(document.getElementById('mediumTermChurnRate').value) / 100;
            const longTermPercent = parseFloat(document.getElementById('longTermPercent').value) / 100;
            const longTermChurn = parseFloat(document.getElementById('longTermChurnRate').value) / 100;
            const cohortSize = parseFloat(document.getElementById('cohortSize').value);
            const timePeriods = parseInt(document.getElementById('timePeriods').value);

            // Simple validation
            if ([shortTermPercent, shortTermChurn, mediumTermPercent, mediumTermChurn, longTermPercent, longTermChurn, cohortSize, timePeriods].some(isNaN)) {
                alert('Please check your inputs for valid numbers.');
                return;
            }

            // Validate that segment percentages sum to 100% (allow 99-101% range)
            const segmentSum = shortTermPercent + mediumTermPercent + longTermPercent;
            if (segmentSum < 0.99 || segmentSum > 1.01) {
                alert(`Warning: Segment percentages must sum to approximately 100%.\nCurrent sum: ${(segmentSum * 100).toFixed(1)}%\n\nshortTerm: ${(shortTermPercent * 100).toFixed(1)}%\nmediumTerm: ${(mediumTermPercent * 100).toFixed(1)}%\nlongTerm: ${(longTermPercent * 100).toFixed(1)}%`);
                return;
            }

            const T = cohortSize * shortTermPercent;
            const M = cohortSize * mediumTermPercent;
            const L = cohortSize * longTermPercent;
            const timePoints = Array.from({ length: timePeriods + 1 }, (_, i) => i);

            // --- RETENTION CALCULATION (3-segment model) ---
            const retentionData = timePoints.map(t => {
                let shortTermRem = (shortTermChurn === 1) ? (t === 0 ? T : 0) : T * Math.pow(1 - shortTermChurn, t);
                let transRem = (mediumTermChurn === 1) ? (t === 0 ? M : 0) : M * Math.pow(1 - mediumTermChurn, t);
                let longTermRem = (longTermChurn === 1) ? (t === 0 ? L : 0) : L * Math.pow(1 - longTermChurn, t);
                return shortTermRem + transRem + longTermRem;
            });

            // --- KPI CALCS: MEDIAN & MEAN ---
            let medianLifetimeStr = 'Infinite';
            let medianLifetime = Infinity;
            const halfCohort = cohortSize / 2;

            if (retentionData[timePeriods] < halfCohort) {
                 // Find where it crosses 50%
                 for (let i = 0; i < timePeriods; i++) {
                    if (retentionData[i] >= halfCohort && retentionData[i+1] < halfCohort) {
                        // Linear interpolation for smoother display
                        const slope = retentionData[i+1] - retentionData[i];
                        medianLifetime = i + (halfCohort - retentionData[i]) / slope;
                        medianLifetimeStr = medianLifetime.toFixed(1) + ' mo';
                        break;
                    }
                 }
            } else if (mediumTermChurn > 0 || longTermChurn > 0) {
                 medianLifetimeStr = '> ' + timePeriods + ' mo';
            }

            let meanLifetime = Infinity;
            if (shortTermChurn > 0 && mediumTermChurn > 0 && longTermChurn > 0) {
                // Weighted average of segment lifetimes
                meanLifetime = (shortTermPercent / shortTermChurn) + (mediumTermPercent / mediumTermChurn) + (longTermPercent / longTermChurn);
                document.getElementById('meanDisplay').innerText = meanLifetime.toFixed(1) + ' mo';
            } else {
                document.getElementById('meanDisplay').innerText = 'Infinite';
            }
            document.getElementById('medianDisplay').innerText = medianLifetimeStr;

            // --- GROWTH CALCULATION (3-segment model) ---
             const growthData = timePoints.map(t => {
                // Sum of all cohorts up to time t (each with 3 segments)
                let total = 0;
                for (let k = 0; k <= t; k++) {
                    const age = t - k;
                    total += (T * Math.pow(1 - shortTermChurn, age)) + 
                             (M * Math.pow(1 - mediumTermChurn, age)) + 
                             (L * Math.pow(1 - longTermChurn, age));
                }
                return total;
            });

            // --- KPI CALCS: ASYMPTOTE ---
            let asymptoteStr = 'No Ceiling (Linear Growth)';
            let isLinear = (shortTermChurn === 0 || mediumTermChurn === 0 || longTermChurn === 0);
            let asymptoteVal = null;
            let linearAsymptoteData = null;

            if (!isLinear) {
                // All segments have churn - finite asymptote
                asymptoteVal = (T / shortTermChurn) + (M / mediumTermChurn) + (L / longTermChurn);
                asymptoteStr = Math.round(asymptoteVal).toLocaleString();
                document.getElementById('asymptoteFormula').innerText = 'Steady state where churn equals new acquisition';
            } else {
                document.getElementById('asymptoteFormula').innerText = 'At least one segment has 0% churn';
                
                // Calculate linear asymptote - sum up the segments
                linearAsymptoteData = timePoints.map(t => {
                    let asymptote = 0;
                    
                    // shortTerm contribution
                    if (shortTermChurn === 0) {
                        asymptote += T * (t + 1); // Linear growth
                    } else {
                        asymptote += T / shortTermChurn; // Steady state
                    }
                    
                    // mediumTerm contribution
                    if (mediumTermChurn === 0) {
                        asymptote += M * (t + 1); // Linear growth
                    } else {
                        asymptote += M / mediumTermChurn; // Steady state
                    }
                    
                    // longTerm contribution
                    if (longTermChurn === 0) {
                        asymptote += L * (t + 1); // Linear growth
                    } else {
                        asymptote += L / longTermChurn; // Steady state
                    }
                    
                    return asymptote;
                });
                
                const growingSegments = [];
                if (shortTermChurn === 0) growingSegments.push(`${T.toFixed(0)} (short-term)`);
                if (mediumTermChurn === 0) growingSegments.push(`${M.toFixed(0)} (medium-term)`);
                if (longTermChurn === 0) growingSegments.push(`${L.toFixed(0)} (long-term)`);
                
                // Calculate steady-state contribution from segments with churn
                let steadyState = 0;
                if (shortTermChurn > 0) steadyState += T / shortTermChurn;
                if (mediumTermChurn > 0) steadyState += M / mediumTermChurn;
                if (longTermChurn > 0) steadyState += L / longTermChurn;
                
                asymptoteStr = `Linear: ${growingSegments.join(' + ')} √ó (t + 1) + ${Math.round(steadyState).toLocaleString()}`;
            }
            document.getElementById('asymptoteDisplay').innerText = asymptoteStr;


            // --- UPDATE CHARTS ---
            
            // 1. Retention Update
            const accentColor = '#2563eb';
            const retentionDatasets = [{
                label: 'Model Prediction',
                data: retentionData,
                borderColor: accentColor,
                backgroundColor: accentColor,
                borderWidth: 2.5,
                pointRadius: 0,
                pointHoverRadius: 6,
                fill: {
                    target: 'origin',
                    above: 'rgba(37, 99, 235, 0.05)' // Very subtle fill
                }
            }];
            
            // Add actual data points if they exist (from curve fitting)
            if (actualRetentionData && actualRetentionData.length > 0) {
                // Convert actual data to absolute numbers (multiply by cohort size)
                const actualPoints = actualRetentionData.map(pct => pct * cohortSize);
                
                retentionDatasets.push({
                    label: 'Actual Data',
                    data: actualPoints,
                    type: 'scatter',
                    borderColor: '#60a5fa',
                    backgroundColor: '#60a5fa',
                    pointRadius: 5,
                    pointHoverRadius: 7,
                    borderWidth: 2,
                    showLine: false
                });
            }
            
            retentionChart.data = {
                labels: timePoints,
                datasets: retentionDatasets
            };

            // Retention Annotations (Median and Mean lines)
            retentionChart.options.plugins.annotation.annotations = {};
            if (isFinite(medianLifetime) && medianLifetime <= timePeriods) {
                 retentionChart.options.plugins.annotation.annotations.medianLine = {
                    type: 'line',
                    xMin: medianLifetime,
                    xMax: medianLifetime,
                    borderColor: '#ef4444',
                    borderWidth: 2,
                    borderDash: [4, 4],
                    label: { display: true, content: 'Median', position: 'end', backgroundColor: '#ef4444', font: {size: 10} }
                 };
            }
            if (isFinite(meanLifetime) && meanLifetime >= 0 && meanLifetime <= timePeriods) {
                 retentionChart.options.plugins.annotation.annotations.meanLine = {
                    type: 'line',
                    xMin: meanLifetime,
                    xMax: meanLifetime,
                    borderColor: '#f97316',
                    borderWidth: 2,
                    borderDash: [6, 3],
                    label: { display: true, content: 'Mean', position: 'start', backgroundColor: '#f97316', font: {size: 10} }
                 };
            }
            retentionChart.update();

            // 2. Growth Update
            const growthColor = '#059669'; // Emerald green
            const datasets = [{
                label: 'Total Customers',
                data: growthData,
                borderColor: growthColor,
                backgroundColor: growthColor,
                borderWidth: 2.5,
                pointRadius: 0,
                pointHoverRadius: 6
            }];
            
            // Add linear asymptote as a separate dataset if it exists
            if (linearAsymptoteData) {
                datasets.push({
                    label: 'Linear Asymptote',
                    data: linearAsymptoteData,
                    borderColor: '#a855f7',
                    borderWidth: 2,
                    borderDash: [8, 4],
                    fill: false,
                    pointRadius: 0,
                    pointHoverRadius: 0
                });
            }
            
            growthChart.data = {
                labels: timePoints,
                datasets: datasets
            };

            // Growth Annotations (Asymptote)
            growthChart.options.plugins.annotation.annotations = {};
            if (asymptoteVal !== null) {
                 growthChart.options.plugins.annotation.annotations.ceilingLine = {
                    type: 'line',
                    yMin: asymptoteVal,
                    yMax: asymptoteVal,
                    borderColor: '#ef4444', // Red for ceiling
                    borderWidth: 1,
                    borderDash: [6, 6],
                    label: { display: true, content: 'Ceiling', position: 'end', backgroundColor: 'rgba(239, 68, 68, 0.8)', font: {size: 10} }
                 };
                 // Ensure y-axis can see the asymptote if it's close
                 growthChart.options.scales.y.suggestedMax = Math.max(growthData[timePeriods] * 1.1, asymptoteVal * 1.05);
            } else {
                growthChart.options.scales.y.suggestedMax = undefined;
            }

            growthChart.update();
        }

        // Help Modal Functions
        function toggleHelp() {
            const modal = document.getElementById('helpModal');
            modal.classList.toggle('active');
        }

        function closeHelpIfClickOutside(event) {
            if (event.target.id === 'helpModal') {
                toggleHelp();
            }
        }

        // Keyboard support for help modal
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const modal = document.getElementById('helpModal');
                if (modal.classList.contains('active')) {
                    toggleHelp();
                }
            }
            // Press Enter anywhere in the controls panel to update charts
            if (event.key === 'Enter' && event.target.tagName === 'INPUT') {
                updateCharts();
            }
        });

        // --- Presets ---
        const PRESETS = {
            saas: {
                name: "SaaS Startup",
                cohortSize: "1000",
                timePeriods: "36",
                shortTermPercent: "30.0",
                shortTermChurnRate: "85.0",
                mediumTermPercent: "50.0",
                mediumTermChurnRate: "12.0",
                longTermPercent: "20.0",
                longTermChurnRate: "2.0"
            },
            ecommerce: {
                name: "E-commerce",
                cohortSize: "2000",
                timePeriods: "24",
                shortTermPercent: "40.0",
                shortTermChurnRate: "70.0",
                mediumTermPercent: "45.0",
                mediumTermChurnRate: "15.0",
                longTermPercent: "15.0",
                longTermChurnRate: "5.0"
            },
            mobile: {
                name: "Mobile App",
                cohortSize: "5000",
                timePeriods: "12",
                shortTermPercent: "75.0",
                shortTermChurnRate: "95.0",
                mediumTermPercent: "20.0",
                mediumTermChurnRate: "25.0",
                longTermPercent: "5.0",
                longTermChurnRate: "8.0"
            },
            enterprise: {
                name: "Enterprise B2B",
                cohortSize: "50",
                timePeriods: "60",
                shortTermPercent: "10.0",
                shortTermChurnRate: "50.0",
                mediumTermPercent: "40.0",
                mediumTermChurnRate: "5.0",
                longTermPercent: "50.0",
                longTermChurnRate: "1.0"
            }
        };

        // --- Export & Share Functions ---
        
        function downloadRetentionChart() {
            const canvas = document.getElementById('retentionChart');
            const url = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'retention-chart.png';
            link.href = url;
            link.click();
        }

        function downloadGrowthChart() {
            const canvas = document.getElementById('growthChart');
            const url = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'growth-chart.png';
            link.href = url;
            link.click();
        }

        function getAllParameters() {
            return {
                cohortSize: document.getElementById('cohortSize').value,
                timePeriods: document.getElementById('timePeriods').value,
                shortTermPercent: document.getElementById('shortTermPercent').value,
                shortTermChurnRate: document.getElementById('shortTermChurnRate').value,
                mediumTermPercent: document.getElementById('mediumTermPercent').value,
                mediumTermChurnRate: document.getElementById('mediumTermChurnRate').value,
                longTermPercent: document.getElementById('longTermPercent').value,
                longTermChurnRate: document.getElementById('longTermChurnRate').value,
                actualData: actualRetentionData // Include fitted data if exists
            };
        }

        function setAllParameters(params) {
            document.getElementById('cohortSize').value = params.cohortSize;
            document.getElementById('timePeriods').value = params.timePeriods;
            document.getElementById('shortTermPercent').value = params.shortTermPercent;
            document.getElementById('shortTermChurnRate').value = params.shortTermChurnRate;
            document.getElementById('mediumTermPercent').value = params.mediumTermPercent;
            document.getElementById('mediumTermChurnRate').value = params.mediumTermChurnRate;
            document.getElementById('longTermPercent').value = params.longTermPercent;
            document.getElementById('longTermChurnRate').value = params.longTermChurnRate;
            
            // Restore actual retention data if it was saved
            if (params.actualData) {
                actualRetentionData = params.actualData;
            }
        }

        function copyShareableLink() {
            const params = getAllParameters();
            delete params.actualData; // Don't include in URL (too long)
            const urlParams = new URLSearchParams(params);
            const shareUrl = window.location.origin + window.location.pathname + '?' + urlParams.toString();
            
            navigator.clipboard.writeText(shareUrl).then(() => {
                alert('‚úÖ Link copied to clipboard! Share this URL to let others view your simulation.');
            }).catch(() => {
                // Fallback for older browsers
                prompt('Copy this link:', shareUrl);
            });
        }

        function loadPreset() {
            const select = document.getElementById('presetSelect');
            const value = select.value;
            
            if (!value) return;
            
            // Check if it's a built-in preset
            if (PRESETS[value]) {
                if (confirm('‚ö†Ô∏è Load this preset?\n\nThis will overwrite your current parameters.')) {
                    setAllParameters(PRESETS[value]);
                    updateCharts();
                }
                select.value = ""; // Reset selection
                return;
            }
            
            // Otherwise it's a saved set
            const savedSets = JSON.parse(localStorage.getItem('simlongTermtySavedSets') || '{}');
            if (savedSets[value]) {
                if (confirm(`‚ö†Ô∏è Load "${value}"?\n\nThis will overwrite your current parameters.`)) {
                    setAllParameters(savedSets[value].params);
                    updateCharts();
                }
                select.value = ""; // Reset selection
            }
        }

        function saveNamedSet() {
            const name = document.getElementById('saveSetName').value.trim();
            if (!name) {
                alert('‚ö†Ô∏è Please enter a name for this parameter set.');
                return;
            }
            
            const savedSets = JSON.parse(localStorage.getItem('simlongTermtySavedSets') || '{}');
            savedSets[name] = {
                params: getAllParameters(),
                timestamp: new Date().toISOString()
            };
            
            localStorage.setItem('simlongTermtySavedSets', JSON.stringify(savedSets));
            document.getElementById('saveSetName').value = '';
            updateSavedSetsList();
            alert(`‚úÖ "${name}" saved successfully!`);
        }

        function updateSavedSetsList() {
            const savedSets = JSON.parse(localStorage.getItem('simlongTermtySavedSets') || '{}');
            const group = document.getElementById('savedSetsGroup');
            group.innerHTML = '';
            
            const names = Object.keys(savedSets).sort();
            if (names.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = '(no saved sets)';
                option.disabled = true;
                group.appendChild(option);
            } else {
                names.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    group.appendChild(option);
                });
            }
        }

        function manageSavedSets() {
            const savedSets = JSON.parse(localStorage.getItem('simlongTermtySavedSets') || '{}');
            const names = Object.keys(savedSets);
            
            if (names.length === 0) {
                alert('‚ÑπÔ∏è No saved sets to manage.');
                return;
            }
            
            const list = names.map((name, i) => `${i + 1}. ${name}`).join('\n');
            const action = prompt(`Your saved sets:\n${list}\n\n‚Ä¢ Enter a set name to DELETE it\n‚Ä¢ Type "CLEAR ALL" to delete all sets\n‚Ä¢ Cancel to go back`);
            
            if (!action) {
                return; // User cancelled
            }
            
            // Check if user wants to clear all
            if (action.toUpperCase() === 'CLEAR ALL') {
                if (confirm(`‚ö†Ô∏è Delete ALL ${names.length} saved sets?\n\nThis cannot be undone!`)) {
                    localStorage.removeItem('simlongTermtySavedSets');
                    updateSavedSetsList();
                    alert(`‚úÖ All saved sets deleted.`);
                }
                return;
            }
            
            // Otherwise try to delete individual set
            if (savedSets[action]) {
                if (confirm(`‚ö†Ô∏è Delete "${action}"?\n\nThis cannot be undone!`)) {
                    delete savedSets[action];
                    localStorage.setItem('simlongTermtySavedSets', JSON.stringify(savedSets));
                    updateSavedSetsList();
                    alert(`‚úÖ "${action}" deleted.`);
                }
            } else {
                alert('‚ö†Ô∏è Set not found.');
            }
        }

        function exportToCSV() {
            // Get current parameters
            const cohortSize = parseFloat(document.getElementById('cohortSize').value);
            const timePeriods = parseInt(document.getElementById('timePeriods').value);
            const shortTermPercent = parseFloat(document.getElementById('shortTermPercent').value) / 100;
            const shortTermChurn = parseFloat(document.getElementById('shortTermChurnRate').value) / 100;
            const mediumTermPercent = parseFloat(document.getElementById('mediumTermPercent').value) / 100;
            const mediumTermChurn = parseFloat(document.getElementById('mediumTermChurnRate').value) / 100;
            const longTermPercent = parseFloat(document.getElementById('longTermPercent').value) / 100;
            const longTermChurn = parseFloat(document.getElementById('longTermChurnRate').value) / 100;

            const T = cohortSize * shortTermPercent;
            const M = cohortSize * mediumTermPercent;
            const L = cohortSize * longTermPercent;

            // Build CSV header - include Actual Data column if we have it
            let csv = 'Month,Short-term Users,Medium-term Users,Long-term Users,Total Retention,Total Customer Base';
            if (actualRetentionData && actualRetentionData.length > 0) {
                csv += ',Actual Data (Fitted)\n';
            } else {
                csv += '\n';
            }
            
            for (let t = 0; t <= timePeriods; t++) {
                const shortTermRem = T * Math.pow(1 - shortTermChurn, t);
                const transRem = M * Math.pow(1 - mediumTermChurn, t);
                const longTermRem = L * Math.pow(1 - longTermChurn, t);
                const totalRetention = shortTermRem + transRem + longTermRem;
                
                // Calculate total customer base (all cohorts)
                let totalBase = 0;
                for (let k = 0; k <= t; k++) {
                    const age = t - k;
                    totalBase += (T * Math.pow(1 - shortTermChurn, age)) + 
                                 (M * Math.pow(1 - mediumTermChurn, age)) + 
                                 (L * Math.pow(1 - longTermChurn, age));
                }
                
                csv += `${t},${Math.round(shortTermRem)},${Math.round(transRem)},${Math.round(longTermRem)},${Math.round(totalRetention)},${Math.round(totalBase)}`;
                
                // Add actual data point if available for this month
                if (actualRetentionData && t < actualRetentionData.length) {
                    const actualUsers = Math.round(actualRetentionData[t] * cohortSize);
                    csv += `,${actualUsers}`;
                }
                csv += '\n';
            }

            // Download
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'sim-loyalty-data.csv';
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }

        // Load parameters from URL on page load
        function loadFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('cohortSize')) {
                const params = {
                    cohortSize: urlParams.get('cohortSize'),
                    timePeriods: urlParams.get('timePeriods'),
                    shortTermPercent: urlParams.get('shortTermPercent'),
                    shortTermChurnRate: urlParams.get('shortTermChurnRate'),
                    mediumTermPercent: urlParams.get('mediumTermPercent'),
                    mediumTermChurnRate: urlParams.get('mediumTermChurnRate'),
                    longTermPercent: urlParams.get('longTermPercent'),
                    longTermChurnRate: urlParams.get('longTermChurnRate')
                };
                setAllParameters(params);
            }
        }

        // Init
        loadFromURL();
        updateSavedSetsList();
        updateCharts();
    </script>
</body>
</html>